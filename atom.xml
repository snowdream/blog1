<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>snowdream - Impossible is nothing!</title>
  
  <subtitle>Email: yanghui1986527#gmail.com    QQ: 273247606    QQ Group：529327615</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://www.snowdream.tech/"/>
  <updated>2018-04-19T02:49:42.023Z</updated>
  <id>http://www.snowdream.tech/</id>
  
  <author>
    <name>snowdream</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>用了WifiManager这么多年，今天才知道彻底用错了</title>
    <link href="http://www.snowdream.tech/2017/11/13/android-wifimanager-leak-context/"/>
    <id>http://www.snowdream.tech/2017/11/13/android-wifimanager-leak-context/</id>
    <published>2017-11-13T12:15:45.000Z</published>
    <updated>2018-04-19T02:49:42.023Z</updated>
    
    <content type="html"><![CDATA[<hr><blockquote><p>作者：snowdream<br>Email：yanghui1986527#gmail.com<br>Github: <a href="https://github.com/snowdream" target="_blank" rel="noopener">https://github.com/snowdream</a><br>原文地址：<a href="https://snowdream.github.io/blog/2017/11/13/android-wifimanager-leak-context/" target="_blank" rel="noopener">https://snowdream.github.io/blog/2017/11/13/android-wifimanager-leak-context/</a></p></blockquote><h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>之前在处理内存泄漏相关问题时，碰到一个奇怪的问题。有一个闪屏界面，由于包含大图片，屡次内存泄漏，屡次修改。屡次修改，屡次还内存泄漏。<br>直到有一天，通过MAT工具分析一个相关hprof文件时，发现一个新的case: 内存泄漏矛头直指WifiManager。<br><img src="https://static.dingtalk.com/media/lALPBbCc1SB50q5GzQKq_682_70.png_620x10000q90g.jpg" alt="android-wifimanager-leak-context"></p><p>关于WifiManager内存泄漏问题，在Android官方网站得到确认：</p><ol><li><a href="https://issuetracker.google.com/issues/36964970" target="_blank" rel="noopener">Memory leak in WifiManager/WifiService of Android 4.2</a></li><li><a href="https://issuetracker.google.com/issues/63244509" target="_blank" rel="noopener">WifiManager use AsyncChannel leading to memory leak</a></li></ol><h2 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h2><p>对于WifiManager，我一直都是这么用的：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">WifiManager wifiManager = ((WifiManager) <span class="keyword">this</span>.getSystemService(Context.WIFI_SERVICE));</span><br></pre></td></tr></table></figure></p><p>但是当我查阅WifiManager相关文档后，我终于改变了看法。<br>在WifiManager官方文档 <a href="https://developer.android.com/reference/android/net/wifi/WifiManager.html" target="_blank" rel="noopener">https://developer.android.com/reference/android/net/wifi/WifiManager.html</a> 中，提到一句话：</p><p>“On releases before N, this object should only be obtained from an application context, and not from any other derived context to avoid memory leaks within the calling process.”</p><p>大概意思便是：<br>在Android N以前，你应该只通过ApplicationContext来获取WifiManager，否则可能面临内存泄漏问题。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">WifiManager wifiManager = ((WifiManager) getApplicationContext().getSystemService(Context.WIFI_SERVICE));</span><br></pre></td></tr></table></figure><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>为什么WifiManager可能发生内存泄漏？</p><p>下面我们具体分析一下：</p><p>以Android 5.1.1_r6为例进行分析。</p><p>1.打开在线源码网站： <a href="http://androidxref.com/" target="_blank" rel="noopener">http://androidxref.com/</a>   。找到ContextImpl.java类源码。</p><p>2.从ContextImpl.java源码中，我们可以看到：一个进程可能创建多个WifiManager。同时，我们把Activity(也就是ctx.getOuterContext())，传给了WifiManager。    </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ContextImpl</span> <span class="keyword">extends</span> <span class="title">Context</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> Object <span class="title">getSystemService</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">     ServiceFetcher fetcher = SYSTEM_SERVICE_MAP.get(name);</span><br><span class="line">     <span class="keyword">return</span> fetcher == <span class="keyword">null</span> ? <span class="keyword">null</span> : fetcher.getService(<span class="keyword">this</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="keyword">static</span> &#123;</span><br><span class="line">   registerService(WIFI_SERVICE, <span class="keyword">new</span> ServiceFetcher() &#123;</span><br><span class="line">          <span class="function"><span class="keyword">public</span> Object <span class="title">createService</span><span class="params">(ContextImpl ctx)</span> </span>&#123;</span><br><span class="line">              IBinder b = ServiceManager.getService(WIFI_SERVICE);</span><br><span class="line">              IWifiManager service = IWifiManager.Stub.asInterface(b);</span><br><span class="line">              <span class="keyword">return</span> <span class="keyword">new</span> WifiManager(ctx.getOuterContext(), service);</span><br><span class="line">          &#125;&#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3.我们再接着浏览 WifiManager源码。这里把Context传给了sAsyncChannel，而这个sAsyncChannel竟然是一个静态变量。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WifiManager</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> AsyncChannel sAsyncChannel;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">WifiManager</span><span class="params">(Context context, IWifiManager service)</span> </span>&#123;</span><br><span class="line">      mContext = context;</span><br><span class="line">      mService = service;</span><br><span class="line">      init();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">synchronized</span> (sThreadRefLock) &#123;</span><br><span class="line">          <span class="keyword">if</span> (++sThreadRefCount == <span class="number">1</span>) &#123;</span><br><span class="line">              Messenger messenger = getWifiServiceMessenger();</span><br><span class="line">              <span class="keyword">if</span> (messenger == <span class="keyword">null</span>) &#123;</span><br><span class="line">                  sAsyncChannel = <span class="keyword">null</span>;</span><br><span class="line">                  <span class="keyword">return</span>;</span><br><span class="line">              &#125;</span><br><span class="line"></span><br><span class="line">              sHandlerThread = <span class="keyword">new</span> HandlerThread(<span class="string">"WifiManager"</span>);</span><br><span class="line">              sAsyncChannel = <span class="keyword">new</span> AsyncChannel();</span><br><span class="line">              sConnected = <span class="keyword">new</span> CountDownLatch(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">              sHandlerThread.start();</span><br><span class="line">              Handler handler = <span class="keyword">new</span> ServiceHandler(sHandlerThread.getLooper());</span><br><span class="line">              sAsyncChannel.connect(mContext, handler, messenger);</span><br><span class="line">              <span class="keyword">try</span> &#123;</span><br><span class="line">                  sConnected.await();</span><br><span class="line">              &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                  Log.e(TAG, <span class="string">"interrupted wait at init"</span>);</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>4.再接着浏览AsyncChannel的源码。这个context被保存在了AsyncChannel内部。<br>换一句话来说：你传进来的Activity/Fragment，被一个静态对象给持有了。一旦这个静态对象没有正确释放，就会造成内存泄漏。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AsyncChannel</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Context for source */</span></span><br><span class="line">    <span class="keyword">private</span> Context mSrcContext;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Connect handler and messenger.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * Sends a CMD_CHANNEL_HALF_CONNECTED message to srcHandler when complete.</span></span><br><span class="line"><span class="comment">     *      msg.arg1 = status</span></span><br><span class="line"><span class="comment">     *      msg.obj = the AsyncChannel</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> srcContext</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> srcHandler</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> dstMessenger</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">connect</span><span class="params">(Context srcContext, Handler srcHandler, Messenger dstMessenger)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (DBG) log(<span class="string">"connect srcHandler to the dstMessenger  E"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// We are connected</span></span><br><span class="line">        connected(srcContext, srcHandler, dstMessenger);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Tell source we are half connected</span></span><br><span class="line">        replyHalfConnected(STATUS_SUCCESSFUL);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (DBG) log(<span class="string">"connect srcHandler to the dstMessenger X"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Connect handler to messenger. This method is typically called</span></span><br><span class="line"><span class="comment">     * when a server receives a CMD_CHANNEL_FULL_CONNECTION request</span></span><br><span class="line"><span class="comment">     * and initializes the internal instance variables to allow communication</span></span><br><span class="line"><span class="comment">     * with the dstMessenger.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> srcContext</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> srcHandler</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> dstMessenger</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">connected</span><span class="params">(Context srcContext, Handler srcHandler, Messenger dstMessenger)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (DBG) log(<span class="string">"connected srcHandler to the dstMessenger  E"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Initialize source fields</span></span><br><span class="line">        mSrcContext = srcContext;</span><br><span class="line">        mSrcHandler = srcHandler;</span><br><span class="line">        mSrcMessenger = <span class="keyword">new</span> Messenger(mSrcHandler);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Initialize destination fields</span></span><br><span class="line">        mDstMessenger = dstMessenger;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (DBG) log(<span class="string">"connected srcHandler to the dstMessenger X"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>5.最后。既然google声称Android 7.0已经改了这个问题。那我们就来围观一下这个改动:WiFiManager中的AsyncChannel已经被声明为普通对象，而不是静态的。</p><p><a href="http://androidxref.com/7.0.0_r1/xref/frameworks/base/wifi/java/android/net/wifi/WifiManager.java#mAsyncChannel" target="_blank" rel="noopener">http://androidxref.com/7.0.0_r1/xref/frameworks/base/wifi/java/android/net/wifi/WifiManager.java#mAsyncChannel</a></p><h2 id="发散"><a href="#发散" class="headerlink" title="发散"></a>发散</h2><p>另外，查询资料，发现不止WiFiManager，还有AudioManager等也可能存在内存泄漏问题。具体参考： <a href="https://android-review.googlesource.com/#/c/platform/frameworks/base/+/140481/" target="_blank" rel="noopener">https://android-review.googlesource.com/#/c/platform/frameworks/base/+/140481/</a></p><p>因此，建议，除了和UI相关的系统service，其他一律使用ApplicationContext来获取。</p><p>欢迎大家关注我的微信公众号:  sn0wdr1am<br><img src="https://static.dingtalk.com/media/lADOmAwFCs0BAs0BAg_258_258.jpg" alt="sn0wdr1am"></p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol><li><a href="https://developer.android.com/reference/android/net/wifi/WifiManager.html" target="_blank" rel="noopener">WifiManager</a></li><li><a href="https://issuetracker.google.com/issues/63244509" target="_blank" rel="noopener">WifiManager use AsyncChannel leading to memory leak</a></li><li><a href="https://issuetracker.google.com/issues/36964970" target="_blank" rel="noopener">Memory leak in WifiManager/WifiService of Android 4.2</a></li><li><a href="https://android-review.googlesource.com/#/c/platform/frameworks/base/+/140481/" target="_blank" rel="noopener">Fix context leak with AudioManager</a></li><li><a href="https://github.com/androidannotations/androidannotations/issues/1628" target="_blank" rel="noopener">@SystemService for WifiManager causes a memory leak #1628</a></li><li><a href="https://github.com/pwittchen/NetworkEvents/issues/106" target="_blank" rel="noopener">Memory leak in WiFiManager from Android SDK</a></li><li><a href="https://stackoverflow.com/a/42639000" target="_blank" rel="noopener">signed apk error [WifiManagerLeak]</a></li><li><a href="https://segmentfault.com/a/1190000004882511" target="_blank" rel="noopener">Android: 记一次Android内存泄露</a></li></ol><h2 id="联系方式"><a href="#联系方式" class="headerlink" title="联系方式"></a>联系方式</h2><ul><li>Email：yanghui1986527#gmail.com</li><li>Github: <a href="https://github.com/snowdream" target="_blank" rel="noopener">https://github.com/snowdream</a></li><li>Blog: <a href="http://snowdream.github.io/blog/" target="_blank" rel="noopener">http://snowdream.github.io/blog/</a></li><li>简书：<a href="http://www.jianshu.com/u/748f0f7e6432" target="_blank" rel="noopener">http://www.jianshu.com/u/748f0f7e6432</a></li><li>云栖博客：<a href="https://yq.aliyun.com/u/snowdream86" target="_blank" rel="noopener">https://yq.aliyun.com/u/snowdream86</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;hr&gt;
&lt;blockquote&gt;
&lt;p&gt;作者：snowdream&lt;br&gt;Email：yanghui1986527#gmail.com&lt;br&gt;Github: &lt;a href=&quot;https://github.com/snowdream&quot; target=&quot;_blank&quot; rel=&quot;n
      
    
    </summary>
    
      <category term="android" scheme="http://www.snowdream.tech/categories/android/"/>
    
    
      <category term="android" scheme="http://www.snowdream.tech/tags/android/"/>
    
  </entry>
  
  <entry>
    <title>学 Kotlin，看这一篇就够了。</title>
    <link href="http://www.snowdream.tech/2017/06/06/full-kotlin-docs/"/>
    <id>http://www.snowdream.tech/2017/06/06/full-kotlin-docs/</id>
    <published>2017-06-06T13:52:20.000Z</published>
    <updated>2018-04-19T02:49:42.023Z</updated>
    
    <content type="html"><![CDATA[<h2 id="为什么学习Kotlin？"><a href="#为什么学习Kotlin？" class="headerlink" title="为什么学习Kotlin？"></a>为什么学习Kotlin？</h2><ol><li><p><a href="https://www.oschina.net/news/84938/android-o-release-with-kotlin" target="_blank" rel="noopener">欢呼声热烈 谷歌宣布 Kotlin 成 Android 开发一级语言</a></p></li><li><p><a href="https://blog.jetbrains.com/kotlin/2017/05/kotlin-on-android-now-official/?spm=a1zb6.8232479.0.0.Zj53Pa" target="_blank" rel="noopener">Kotlin on Android. Now official</a></p></li><li><p><a href="https://www.oschina.net/news/85468/what-do-17-google-developers-experts-for-kotlin" target="_blank" rel="noopener">17 位谷歌 Android 开发专家是如何看待 Kotlin 的？</a></p></li><li><p><a href="https://www.oschina.net/news/85488/why-you-should-totally-switch-to-kotlin" target="_blank" rel="noopener">为什么你该摒弃 Java ，全面转向 Kotlin 语言？</a></p></li><li><p><a href="http://mp.weixin.qq.com/s?__biz=MzA3NTYzODYzMg==&amp;mid=404087761&amp;idx=1&amp;sn=d80625ee52f860a7a2ed4c238d2151b6" target="_blank" rel="noopener">为什么说Kotlin值得一试</a></p></li></ol><h2 id="如何学习Kotlin？"><a href="#如何学习Kotlin？" class="headerlink" title="如何学习Kotlin？"></a>如何学习Kotlin？</h2><h3 id="官网以及相关文档"><a href="#官网以及相关文档" class="headerlink" title="官网以及相关文档"></a>官网以及相关文档</h3><ol><li><p><a href="https://kotlinlang.org" target="_blank" rel="noopener">Kotlin 官网</a></p></li><li><p><a href="https://kotlinlang.org/docs/reference/" target="_blank" rel="noopener">Kotlin 文档</a></p></li><li><p><a href="https://blog.jetbrains.com/kotlin/" target="_blank" rel="noopener">Kotlin 博客</a></p></li><li><p><a href="http://www.kotlincn.net/docs/reference/" target="_blank" rel="noopener">Kotlin 中文文档</a></p></li><li><p><a href="https://github.com/JetBrains/kotlin" target="_blank" rel="noopener">Kotlin on GitHub</a></p></li></ol><h3 id="Kotlin开发实践"><a href="#Kotlin开发实践" class="headerlink" title="Kotlin开发实践"></a>Kotlin开发实践</h3><ol><li><p><a href="http://kotlinlang.org/docs/tutorials/kotlin-android.html" target="_blank" rel="noopener">Getting started with Android and Kotlin</a></p></li><li><p><a href="http://kotlinlang.org/docs/tutorials/android-plugin.html" target="_blank" rel="noopener">Kotlin Android Extensions</a></p></li><li><p><a href="http://kotlinlang.org/docs/tutorials/android-frameworks.html" target="_blank" rel="noopener">Android Frameworks Using Annotation Processing</a></p></li><li><p><a href="https://github.com/JetBrains/kotlin-examples" target="_blank" rel="noopener">kotlin-examples</a></p></li><li><p><a href="http://kotlinlang.org/docs/reference/java-interop.html" target="_blank" rel="noopener">Calling Java code from Kotlin</a></p></li><li><p><a href="http://kotlinlang.org/docs/reference/java-to-kotlin-interop.html" target="_blank" rel="noopener">Calling Kotlin from Java</a></p></li><li><p><a href="http://www.jianshu.com/p/2161ba6e56cf" target="_blank" rel="noopener">使用Kotlin开发Android应用</a></p></li><li><p><a href="https://github.com/mcxiaoke/kotlin-notes/blob/master/slides.md" target="_blank" rel="noopener">Kotlin入门和使用讲稿(PPT)</a></p></li><li><p><a href="https://github.com/mcxiaoke/kotlin-notes/blob/master/notes.md" target="_blank" rel="noopener">Kotlin入门和使用讲稿(文本)</a></p></li><li><p><a href="https://github.com/enbandari/Kotlin-Tutorials" target="_blank" rel="noopener">Kotlin从入门到『放弃』系列 视频教程</a></p></li><li><p><a href="https://news.realm.io/cn/news/droidcon-michael-pardo-kotlin/" target="_blank" rel="noopener">Kotlin: Java 6 废土中的一线希望</a></p></li><li><p><a href="https://news.realm.io/cn/news/oredev-jake-wharton-kotlin-advancing-android-dev/" target="_blank" rel="noopener">Kotlin 语言高级安卓开发入门</a></p></li><li><p><a href="https://wangjiegulu.gitbooks.io/kotlin-for-android-developers-zh/content/" target="_blank" rel="noopener">《Kotlin for android developers》中文版</a></p></li><li><p><a href="https://mp.weixin.qq.com/s?__biz=MzIzMTYzOTYzNA==&amp;mid=2247483875&amp;idx=1&amp;sn=b1b565f651ee1221d4bda19ab12009ce" target="_blank" rel="noopener">深入理解 Kotlin Coroutine（一）</a></p></li><li><p><a href="https://mp.weixin.qq.com/s?__biz=MzIzMTYzOTYzNA==&amp;mid=2247483878&amp;idx=1&amp;sn=710189e6e22a13fc7d1ea67bc2dd9270&amp;chksm=e8a05edbdfd7d7cd163ee1a2d5769fc2bf003e2d5a6d3f9c6382531b7efc22a6ab75300bb906#rd" target="_blank" rel="noopener">深入理解 Kotlin Coroutine（二）</a></p></li><li><p><a href="https://mp.weixin.qq.com/s?__biz=MzIzMTYzOTYzNA==&amp;mid=2247483899&amp;idx=1&amp;sn=7d24a9aecb00c80c9c6165b48660394c&amp;chksm=e8a05ec6dfd7d7d0842d41d79bad3d099afddc0c5c8012ada18a1b3f2a13aa314127b91e3a15#rd" target="_blank" rel="noopener">Kotlin Script 及其运行机制简析</a></p></li><li><p><a href="http://www.kotliner.cn/2017/04/15/Kotlin%20Native%20详细体验，你想要的都在这儿/" target="_blank" rel="noopener">Kotlin Native 详细体验，你想要的都在这儿</a></p></li></ol><h2 id="Kotlin相关类库和资源"><a href="#Kotlin相关类库和资源" class="headerlink" title="Kotlin相关类库和资源"></a>Kotlin相关类库和资源</h2><h3 id="Libraries"><a href="#Libraries" class="headerlink" title="Libraries"></a>Libraries</h3><ol><li><a href="https://github.com/Kotlin/anko" target="_blank" rel="noopener">Kotlin/anko</a> - Pleasant Android application development.</li><li><a href="https://github.com/JakeWharton/kotterknife" target="_blank" rel="noopener">JakeWharton/kotterknife</a> - View injection library for Android.</li><li><a href="https://github.com/MarcinMoskala/ActivityStarter" target="_blank" rel="noopener">MarcinMoskala/ActivityStarter</a> - Activity starter generator and arguments injection library for Android.</li><li><a href="https://github.com/MarcinMoskala/KotlinPreferences" target="_blank" rel="noopener">MarcinMoskala/KotlinPreferences</a> - Kotlin Android Library, that makes preference usage in Kotlin simple and fun.</li><li><a href="https://github.com/MarcinMoskala/PreferenceHolder" target="_blank" rel="noopener">MarcinMoskala/PreferenceHolder</a> - Kotlin Android Library, that makes preference usage in Kotlin simple and fun using object with fields binded to SharedPreferences.</li><li><a href="https://github.com/nsk-mironov/kotlin-jetpack" target="_blank" rel="noopener">nsk-mironov/kotlin-jetpack</a> - A collection of useful extension methods for Android.</li><li><a href="https://github.com/pawegio/KAndroid" target="_blank" rel="noopener">pawegio/KAndroid</a> - Kotlin library for Android providing useful extensions to eliminate boilerplate code.</li><li><a href="https://github.com/chibatching/Kotpref" target="_blank" rel="noopener">chibatching/Kotpref</a> - Android SharedPreference delegation for Kotlin.</li><li><a href="https://github.com/TouK/bubble" target="_blank" rel="noopener">TouK/bubble</a> - Library for obtaining screen orientation when orientation is blocked in AndroidManifest.</li><li><a href="https://github.com/ragunathjawahar/kaffeine" target="_blank" rel="noopener">ragunathjawahar/kaffeine</a> - Kaffeine is a Kotlin-flavored Android library for accelerating development.</li><li><a href="https://github.com/mcxiaoke/kotlin-koi" target="_blank" rel="noopener">mcxiaoke/kotlin-koi</a> - Koi, a lightweight kotlin library for Android Development.</li><li><a href="https://github.com/BennyWang/KBinding" target="_blank" rel="noopener">BennyWang/KBinding</a> - Android View Model binding framework write in kotlin, base on anko, simple but powerful.</li><li><a href="https://github.com/inaka/KillerTask" target="_blank" rel="noopener">inaka/KillerTask</a> -  Android AsyncTask wrapper library, written in Kotlin.</li><li><a href="https://github.com/grandstaish/paperparcel" target="_blank" rel="noopener">grandstaish/paperparcel</a> - Boilerplate reduction library written specifically for working with Kotlin data classes on Android.</li><li><a href="https://github.com/andre-artus/AnvilKotlin" target="_blank" rel="noopener">andre-artus/AnvilKotlin</a> - Minimal UI library for Android inspired by React.</li><li><a href="https://github.com/mathcamp/fiberglass" target="_blank" rel="noopener">mathcamp/fiberglass</a> - Easy lightweight SharedPreferences library for Android in Kotlin using delegated properties.</li><li><a href="https://github.com/nitrico/LastAdapter" target="_blank" rel="noopener">nitrico/LastAdapter</a> - Don’t write a RecyclerView adapter again. Not even a ViewHolder!.</li><li><a href="https://github.com/denisidoro/krouter" target="_blank" rel="noopener">denisidoro/krouter</a> - A lightweight Android activity router.</li><li><a href="https://github.com/metalabdesign/AsyncAwait" target="_blank" rel="noopener">metalabdesign/AsyncAwait</a> - async/await for Android built upon coroutines introduced in Kotlin 1.1.</li><li><a href="https://github.com/jupf/staticlog" target="_blank" rel="noopener">jupf/staticlog</a> - StaticLog - super lightweight static logging for Kotlin, Java and Android.</li><li><a href="https://github.com/zserge/anvil" target="_blank" rel="noopener">zserge/anvil</a> - Minimal UI library for Android inspired by React.</li><li><a href="https://github.com/DanielMartinus/Stepper-Touch" target="_blank" rel="noopener">DanielMartinus/Stepper-Touch</a> - Fun playful Android stepper widget for counting, written in Kotlin.</li><li><a href="https://github.com/GlimpseFramework/glimpse-framework-android" target="_blank" rel="noopener">GlimpseFramework/glimpse-framework-android</a> - OpenGL made simple.</li><li><a href="https://github.com/infotech-group/android-drawable-dsl" target="_blank" rel="noopener">infotech-group/android-drawable-dsl</a> - DSL for constructing the drawables in Kotlin instead of in XML.</li><li><a href="https://github.com/zsmb13/MaterialDrawerKt" target="_blank" rel="noopener">zsmb13/MaterialDrawerKt</a> - A DSL for creating Material Design navigation drawers without any XML.</li><li><a href="https://github.com/SnowdreamFramework/ToyBricks" target="_blank" rel="noopener">SnowdreamFramework/ToyBricks</a> - Android Library that provide simpler way to achieve modularity.</li></ol><h3 id="Frameworks"><a href="#Frameworks" class="headerlink" title="Frameworks"></a>Frameworks</h3><ol><li><a href="https://github.com/nekocode/kotgo" target="_blank" rel="noopener">nekocode/kotgo</a> - An android development framwork on kotlin using MVP architecture.</li><li><a href="https://github.com/lightningkite/kotlin-core" target="_blank" rel="noopener">lightningkite/kotlin-core</a> - A full framework for making Android apps. Based on Anko and Kotson.</li></ol><h3 id="Projects"><a href="#Projects" class="headerlink" title="Projects"></a>Projects</h3><ol><li><a href="https://github.com/antoniolg/Bandhook-Kotlin" target="_blank" rel="noopener">antoniolg/Bandhook-Kotlin</a> - A showcase music app for Android entirely written using Kotlin language.</li><li><a href="https://github.com/antoniolg/Kotlin-for-Android-Developers" target="_blank" rel="noopener">antoniolg/Kotlin-for-Android-Developers</a> - Companion App for the book “Kotlin Android Developers”.</li><li><a href="https://github.com/damianpetla/kotlin-dagger-example" target="_blank" rel="noopener">damianpetla/kotlin-dagger-example</a> - Example of Android project showing integration with Kotlin and Dagger 2.</li><li><a href="https://github.com/dodyg/AndroidRivers" target="_blank" rel="noopener">dodyg/AndroidRivers</a> - RSS Readers for Android.</li><li><a href="https://github.com/MakinGiants/banjen-android-banjo-tuner" target="_blank" rel="noopener">MakinGiants/banjen-android-banjo-tuner</a> - App that plays sounds helping to tune a brazilian banjo.</li><li><a href="https://github.com/inaka/kotlillon" target="_blank" rel="noopener">inaka/kotlillon</a> - Android Kotlin Examples.</li><li><a href="https://github.com/MakinGiants/todayhistory" target="_blank" rel="noopener">MakinGiants/todayhistory</a> - App that shows what happened today in history.</li><li><a href="https://github.com/RxKotlin/Pocket" target="_blank" rel="noopener">RxKotlin/Pocket</a> - This app help user to save links easily, and can export to Evernote as weekly.</li><li><a href="https://github.com/SidneyXu/AndroidDemoIn4Languages" target="_blank" rel="noopener">SidneyXu/AndroidDemoIn4Languages</a> - Comparison between Java, Groovy, Scala, Kotlin in Android Development.</li><li><a href="https://github.com/inorichi/tachiyomi" target="_blank" rel="noopener">inorichi/tachiyomi</a> -  Free and open source manga reader for Android.</li><li><a href="https://github.com/ziggy42/Blum-kotlin" target="_blank" rel="noopener">ziggy42/Blum-kotlin</a> - A simple android Twitter client written in Kotlin</li><li><a href="https://github.com/TwidereProject/Twidere-Android" target="_blank" rel="noopener">TwidereProject/Twidere-Android</a> - Material Design ready and feature rich Twitter app for Android 4.0+</li><li><a href="https://github.com/SimpleMobileTools/Simple-Calendar" target="_blank" rel="noopener">SimpleMobileTools/Simple-Calendar</a> - A simple calendar with events, customizable widget and no ads.</li><li><a href="https://github.com/SimpleMobileTools/Simple-Camera" target="_blank" rel="noopener">SimpleMobileTools/Simple-Camera</a> - A camera with flash, zoom and no ads.</li><li><a href="https://github.com/SimpleMobileTools/Simple-Draw" target="_blank" rel="noopener">SimpleMobileTools/Simple-Draw</a> - A canvas you can draw on with different colors.</li><li><a href="https://github.com/SimpleMobileTools/Simple-File-Manager" target="_blank" rel="noopener">SimpleMobileTools/Simple-File-Manager</a> - A simple file manager for browsing and editing files and directories.</li><li><a href="https://github.com/SimpleMobileTools/Simple-Gallery" target="_blank" rel="noopener">SimpleMobileTools/Simple-Gallery</a> - A gallery for viewing photos and videos without ads.</li><li><a href="https://github.com/SimpleMobileTools/Simple-Notes" target="_blank" rel="noopener">SimpleMobileTools/Simple-Notes</a> - A simple textfield for adding quick notes without ads.</li></ol><h3 id="Extensions"><a href="#Extensions" class="headerlink" title="Extensions"></a>Extensions</h3><ol><li><a href="https://github.com/ajalt/timberkt" target="_blank" rel="noopener">ajalt/timberkt</a> - Easy Android logging with Kotlin and Timber.</li></ol><h3 id="Tools"><a href="#Tools" class="headerlink" title="Tools"></a>Tools</h3><ol><li><a href="https://github.com/kiruto/debug-bottle" target="_blank" rel="noopener">kiruto/debug-bottle</a> - Debug Bottle is an Android runtime debug / develop tools written using kotlin language.</li></ol><h3 id="Websites"><a href="#Websites" class="headerlink" title="Websites"></a>Websites</h3><ol><li><p><a href="https://github.com/KotlinBy/awesome-kotlin" target="_blank" rel="noopener">awesome-kotlin</a></p></li><li><p><a href="https://kotlin.link/" target="_blank" rel="noopener">kotlin.link</a></p></li></ol><h2 id="联系方式"><a href="#联系方式" class="headerlink" title="联系方式"></a>联系方式</h2><ul><li>Email：yanghui1986527#gmail.com</li><li>Github: <a href="https://github.com/snowdream" target="_blank" rel="noopener">https://github.com/snowdream</a></li><li>Blog: <a href="http://snowdream.github.io/blog/" target="_blank" rel="noopener">http://snowdream.github.io/blog/</a></li><li>简书：<a href="http://www.jianshu.com/u/748f0f7e6432" target="_blank" rel="noopener">http://www.jianshu.com/u/748f0f7e6432</a></li><li>云栖博客：<a href="https://yq.aliyun.com/u/snowdream86" target="_blank" rel="noopener">https://yq.aliyun.com/u/snowdream86</a> </li><li>QQ群: 529327615     </li><li>微信公众号:  sn0wdr1am    </li></ul><p><img src="https://static.dingtalk.com/media/lADOmAwFCs0BAs0BAg_258_258.jpg" alt="sn0wdr1am"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;为什么学习Kotlin？&quot;&gt;&lt;a href=&quot;#为什么学习Kotlin？&quot; class=&quot;headerlink&quot; title=&quot;为什么学习Kotlin？&quot;&gt;&lt;/a&gt;为什么学习Kotlin？&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;&lt;p&gt;&lt;a href=&quot;https://www.
      
    
    </summary>
    
      <category term="android" scheme="http://www.snowdream.tech/categories/android/"/>
    
    
      <category term="android" scheme="http://www.snowdream.tech/tags/android/"/>
    
  </entry>
  
  <entry>
    <title>ToyBricks用户手册</title>
    <link href="http://www.snowdream.tech/2017/05/07/ToyBricks-Manual/"/>
    <id>http://www.snowdream.tech/2017/05/07/ToyBricks-Manual/</id>
    <published>2017-05-07T12:32:22.000Z</published>
    <updated>2018-04-19T02:49:42.007Z</updated>
    
    <content type="html"><![CDATA[<p>注：阅读本文之前，建议先阅读一下：<br><a href="https://mp.weixin.qq.com/s?__biz=MzIyNTczOTYwMA==&amp;mid=2247483911&amp;idx=1&amp;sn=16a661bee016146fa7ee83f15a0ea615&amp;chksm=e87a5438df0ddd2e847a742fca7c5e31538350a1585158ee72a31f83cf4dc549aff13080c5f7#rd" target="_blank" rel="noopener">ToyBricks简介以及原理分析</a></p><h3 id="ToyBricks简介"><a href="#ToyBricks简介" class="headerlink" title="ToyBricks简介"></a>ToyBricks简介</h3><p>ToyBricks是一个Android项目模块化的解决方案，主要包括四个部分，APT注解，APT注解处理器，ToyBricks插件（Gradle Plugin）,ToyBricks库。</p><p><img src="http://upload-images.jianshu.io/upload_images/66954-57bf455f0fdee874.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="ToyBricks简介"></p><p>其中：</p><ol><li>APT注解，主要定义了两个注解：Interface（接口，例如：IText）,Implementation （实现，例如：TextImpl）</li><li>APT注解处理器，在javac编译java源码之前。APT注解处理器会扫描Java源码中带有上面两个注解的接口和类，并且生成一个json文件， ToyBricks.json.</li><li>ToyBricks插件（Gradle Plugin）,负责ToyBricks.json的打包，合并，生成Java源文件等工作</li><li>ToyBricks，提供对外调用方法。通过参数传入接口，返回相应的实现。</li></ol><h3 id="ToyBricks特性"><a href="#ToyBricks特性" class="headerlink" title="ToyBricks特性"></a>ToyBricks特性</h3><ol><li>同时支持Kotlin，Java</li><li>支持Android Build Variants</li><li>Proguard免配置</li></ol><h3 id="ToyBricks局限性"><a href="#ToyBricks局限性" class="headerlink" title="ToyBricks局限性"></a>ToyBricks局限性</h3><p>ToyBricks具有传染性。<br>任何Android Application 或者 Android Library 使用包含ToyBricks.json的jar包或者aar包作为依赖，都必须继续使用ToyBricks，否则无法保证代码能正确运行。</p><h3 id="ToyBricks规则"><a href="#ToyBricks规则" class="headerlink" title="ToyBricks规则"></a>ToyBricks规则</h3><p><strong>每个模块分为接口和实现两个部分。接口部分提供给模块外部调用，而实现部分则禁止来自外部的调用。</strong></p><p><img src="http://upload-images.jianshu.io/upload_images/66954-3c4fa19a7bfca742.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="模块划分"></p><p><strong>接口</strong> 以@Interface进行注解，示例如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Interface</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">IText</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function">String <span class="title">getText</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><strong>实现</strong> 以@Implementation进行注解，示例如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Implementation</span>(IText.class)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NewTextImpl</span> <span class="keyword">implements</span> <span class="title">IText</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getText</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"NewTextImpl Implementation from "</span>+ getClass().getCanonicalName();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>@Implementation更详细的使用方法如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Implementation</span>(value = IText.class,global = <span class="keyword">true</span>,singleton = <span class="keyword">true</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NewTextGobalImpl</span> <span class="keyword">implements</span> <span class="title">IText</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getText</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"NewTextImpl Implementation from "</span>+ getClass().getCanonicalName() ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>参数说明如下：</p><ol><li>value后面应该填写接口的class</li><li>global代表这个实现拥有高优先级。如果没有设置，默认取值为false。</li><li>singleton代表这个实现将会以单例形式存在。如果没有设置，默认取值为false。由于单例会一直存在于APP的整个生命周期，因此，不应该滥用单例。</li></ol><p>使用ToyBricks应该遵守以下规则：</p><ol><li>接口命令强烈建议以I开头，例如：IText</li><li>每一个接口都必须至少有一个相应实现，否则编译出错。</li><li>每个实现类必须是public的。</li><li>每个实现类必须实现注解中标明的接口。</li><li>每个实现类必须拥有一个默认无参数的构造函数。</li><li>每个实现类不可以是abstract抽象类。</li><li>实现一共分成三类，全局实现（global=true）,普通实现(global=false),替补实现(按照默认的包名和类名进行加载)。它们的优先级从前往后一直降低。<strong>每一类只能同时存在一个实现，否则编译出错。</strong></li><li>替补实现遵循以下规则：<br>假如接口为：com.github.snowdream.toybricks.app.IText,<br>则替补实现为：com.github.snowdream.toybricks.app.impl.TextImpl<br>实现的包名为接口的包名+”.impl”,实现的类名为接口名去掉第一个字母，第二个字母大写，然后加上”Impl”。</li><li>任何发布到Maven仓库的库，都应该将global设置为false。global设置为true，只适合Android Application测试新实现，或者替换默认实现。</li></ol><h3 id="ToyBricks使用方法"><a href="#ToyBricks使用方法" class="headerlink" title="ToyBricks使用方法"></a>ToyBricks使用方法</h3><p>由于ToyBricks对Android的Gradle编译流程稍微进行了修改，因此，请注意按照下面的说明进行详细操作。<br>对于编译流程的修改如下：</p><ol><li>Android Application模块：首先按照上面的步骤生成ToyBricks.json，然后和依赖库中的ToyBricks.json进行合并，校验，最后按照预定规则，生成InterfaceLoaderImpl.java源代码，并参与编译。</li><li>Android Library: 通过APT生成Json文件（ToyBricks.json，生成目录在“build/generated/source/apt”或者“build/generated/source/kapt”），然后打包到aar。如果你需要打包成jar包，并发布到maven仓库，请参考下面代码:         </li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">task <span class="title">androidReleaseJar</span><span class="params">(type: Jar,dependsOn: <span class="string">"assembleRelease"</span>)</span> </span>&#123;</span><br><span class="line">    from <span class="string">"$buildDir/intermediates/classes/release/"</span></span><br><span class="line">    from <span class="string">"$buildDir/generated/source/kapt/release/ToyBricks.json"</span></span><br><span class="line">    from <span class="string">"$buildDir/generated/source/apt/release/ToyBricks.json"</span></span><br><span class="line">    exclude <span class="string">'**/BuildConfig.class'</span></span><br><span class="line">    exclude <span class="string">'**/R.class'</span></span><br><span class="line">    exclude <span class="string">'**/R$*.class'</span></span><br><span class="line">    includeEmptyDirs <span class="keyword">false</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">task <span class="title">androidJavadocsJar</span><span class="params">(type: Jar)</span> </span>&#123;</span><br><span class="line">    classifier = <span class="string">'javadoc'</span></span><br><span class="line">    from <span class="string">"generateReleaseJavadoc.destinationDir"</span></span><br><span class="line">    includeEmptyDirs <span class="keyword">false</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">task <span class="title">androidSourcesJar</span><span class="params">(type: Jar)</span> </span>&#123;</span><br><span class="line">    classifier = <span class="string">'sources'</span></span><br><span class="line">    from android.sourceSets.main.java.srcDirs</span><br><span class="line">    from <span class="string">"$buildDir/generated/source/kapt/release/ToyBricks.json"</span></span><br><span class="line">    from <span class="string">"$buildDir/generated/source/apt/release/ToyBricks.json"</span></span><br><span class="line">    includeEmptyDirs <span class="keyword">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Gradle主工程"><a href="#Gradle主工程" class="headerlink" title="Gradle主工程"></a>Gradle主工程</h4><p>在主工程的build.gradle文件中添加ToyBricks的gradle插件。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">buildscript &#123;</span><br><span class="line">    repositories &#123;</span><br><span class="line">        jcenter()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    dependencies &#123;</span><br><span class="line">        classpath <span class="string">'com.android.tools.build:gradle:2.2.2'</span></span><br><span class="line">        </span><br><span class="line">        classpath <span class="string">'com.github.snowdream.toybricks:android-toybricks-gradle-plugin:0.9.10'</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="Android-Library模块"><a href="#Android-Library模块" class="headerlink" title="Android Library模块"></a>Android Library模块</h4><p>在Library模块的build.gradle文件中添加ToyBricks的相关库依赖。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">kapt &#123;</span><br><span class="line">    generateStubs = <span class="keyword">true</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">dependencies &#123;</span><br><span class="line">    compile <span class="string">"com.github.snowdream:toybricks:0.9.10@aar"</span></span><br><span class="line">    compile <span class="string">"com.github.snowdream.toybricks:annotation:0.9.10"</span></span><br><span class="line"></span><br><span class="line">    kapt <span class="string">"com.github.snowdream.toybricks:processor:0.9.10"</span></span><br><span class="line">    <span class="comment">//annotationProcessor "com.github.snowdream.toybricks:processor:0.9.10"</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">apply plugin: <span class="string">'com.github.snowdream.toybricks'</span></span><br></pre></td></tr></table></figure></p><p><strong>注：</strong> 有两种引用方式，一种是kotlin的kapt方式，需要配置上面的generateStubs。另外一种，是Android默认支持的annotationProcessor方式。</p><p><strong>如果你的工程中包含任何Kotlin源文件，则必须选择kapt的方式，否则，可以选择annotationProcessor方式。</strong></p><h4 id="Android-Application模块"><a href="#Android-Application模块" class="headerlink" title="Android Application模块"></a>Android Application模块</h4><p>在Application模块的build.gradle文件中添加ToyBricks的相关库依赖。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">kapt &#123;</span><br><span class="line">    generateStubs = <span class="keyword">true</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">dependencies &#123;</span><br><span class="line">    compile <span class="string">'com.github.snowdream:annotation:0.7@aar'</span></span><br><span class="line"></span><br><span class="line">    compile <span class="string">"com.github.snowdream:toybricks:0.9.10@aar"</span></span><br><span class="line">    compile <span class="string">"com.github.snowdream.toybricks:annotation:0.9.10"</span></span><br><span class="line"></span><br><span class="line">    kapt <span class="string">"com.github.snowdream.toybricks:processor:0.9.10"</span></span><br><span class="line">    <span class="comment">//annotationProcessor "com.github.snowdream.toybricks:processor:0.9.10"</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">apply plugin: <span class="string">'com.github.snowdream.toybricks'</span></span><br></pre></td></tr></table></figure></p><h4 id="ToyBricks使用方法-1"><a href="#ToyBricks使用方法-1" class="headerlink" title="ToyBricks使用方法"></a>ToyBricks使用方法</h4><p>通过上面的方式，开发好接口和实现模块后。只需要引用接口，就可以通过下面方式获取接口的实现：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">IText text = ToyBricks.getImplementation(IText.class);</span><br></pre></td></tr></table></figure></p><p>其中，IText为接口。</p><h4 id="ToyBricks最佳实践"><a href="#ToyBricks最佳实践" class="headerlink" title="ToyBricks最佳实践"></a>ToyBricks最佳实践</h4><p>按照替补实现的命名规则，来开发接口的实现类。</p><p>如果您对ToyBricks有什么问题或者建议，欢迎通过后面的联系方式联系我。</p><h3 id="参考资料："><a href="#参考资料：" class="headerlink" title="参考资料："></a>参考资料：</h3><ol><li><a href="https://github.com/SnowdreamFramework/ToyBricks" target="_blank" rel="noopener">SnowdreamFramework/ToyBricks</a></li><li><a href="https://github.com/SnowdreamFramework/log" target="_blank" rel="noopener">SnowdreamFramework/log</a></li></ol><h3 id="联系方式"><a href="#联系方式" class="headerlink" title="联系方式"></a>联系方式</h3><ul><li>Email：yanghui1986527#gmail.com</li><li>Github: <a href="https://github.com/snowdream" target="_blank" rel="noopener">https://github.com/snowdream</a></li><li>Blog: <a href="http://snowdream.github.io/blog/" target="_blank" rel="noopener">http://snowdream.github.io/blog/</a></li><li>简书：<a href="http://www.jianshu.com/u/748f0f7e6432" target="_blank" rel="noopener">http://www.jianshu.com/u/748f0f7e6432</a></li><li>云栖博客：<a href="https://yq.aliyun.com/u/snowdream86" target="_blank" rel="noopener">https://yq.aliyun.com/u/snowdream86</a> </li><li>QQ群: 529327615     </li><li>微信公众号:  sn0wdr1am    </li></ul><p><img src="https://static.dingtalk.com/media/lADOmAwFCs0BAs0BAg_258_258.jpg" alt="sn0wdr1am"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;注：阅读本文之前，建议先阅读一下：&lt;br&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MzIyNTczOTYwMA==&amp;amp;mid=2247483911&amp;amp;idx=1&amp;amp;sn=16a661bee016146fa7ee8
      
    
    </summary>
    
      <category term="android" scheme="http://www.snowdream.tech/categories/android/"/>
    
    
      <category term="android" scheme="http://www.snowdream.tech/tags/android/"/>
    
  </entry>
  
  <entry>
    <title>ToyBricks简介以及原理分析</title>
    <link href="http://www.snowdream.tech/2017/05/03/ToyBricks-Introduction/"/>
    <id>http://www.snowdream.tech/2017/05/03/ToyBricks-Introduction/</id>
    <published>2017-05-03T13:03:51.000Z</published>
    <updated>2018-04-19T02:49:42.007Z</updated>
    
    <content type="html"><![CDATA[<h2 id="ToyBricks背景"><a href="#ToyBricks背景" class="headerlink" title="ToyBricks背景"></a>ToyBricks背景</h2><p>我始终认为，在高内聚，低耦合的原则下，进行组件化，模块化，插件化都是移动应用开发的趋势。</p><p>为什么这么说呢？下面我们举个栗子：<br>大家都知道，以前Android应用开发中，可以使用HttpClient或者HttpUrlConnection来进行http访问。这里假设有一个耦合严重，但代码量巨大的项目，使用了基于HttpClient封装的<a href="https://github.com/loopj/android-async-http" target="_blank" rel="noopener">loopj/android-async-http</a>来进行http访问。但是，后来，Google明确支持使用HttpUrlConnection。此时，经过调研，你们觉得<a href="https://github.com/square/okhttp" target="_blank" rel="noopener">square/okhttp</a>基于HttpUrlConnection，符合你们的要求。</p><p>现在，不管是否将HttpClient替换成okhttp，你们都可能面临以下困境：</p><ol><li>需求都做不完，根本没有排期做这个替换。于是，你们面临离google的支持越来越远，离风险越来越近的困境；</li><li>辛辛苦苦耗费人力将HttpClient替换成okhttp。但由于两者变化很大，需要投入很多测试资源，来重新确认这些接口是否正常访问。一旦出现问题，还需要安排研发资源，去一一排查。</li><li>替换的工作量太大。替换一部分之后，发现没有足够人力去继续完成。于是，替换终止。整个工程又变得混乱和臃肿，同时包含了两种http的封装库和调用。</li></ol><p><strong>模块化可以有效解决这些问题。通用的做法，是按照业务，功能等将整个项目分成不同的模块，由不同的研发测试小组负责。<br>每个模块又分为接口和实现两个部分。接口部分提供给模块外部调用，而实现部分则禁止来自外部的调用。</strong></p><img src="/2017/05/03/ToyBricks-Introduction/apt.svg" title="[apt]"><p>那么，如何将模块的接口和实现部分关联起来呢？通过APT工具，可以轻松地将接口部分和实现部分关联起来。</p><p>APT，即Annotation Processing Tool,可以理解为“编译时注解处理器工具”。</p><p>官方说明：<br>“The apt tool is a command-line utility for annotation processing. It includes a set of reflective APIs and supporting infrastructure to process program annotations (JSR 175). These reflective APIs provide a build-time, source-based, read-only view of program structure. They are designed to cleanly model the Java programming language’s type system after the addition of generics (JSR 14).”</p><p>简单理解如下：<br>apt工具是javac工具的一部分。在编译时，apt工具首先会扫描工程下Java源码中的编译时注解，再根据预先定义的编译时注解处理工具，生成指定的Java源码文件。紧接着，生成的Java源码文件和之前项目下的Java源码一起，由javac工具来编译成class。</p><p><strong>但是，APT有一个局限性，就是只会扫描Java源码，不会扫描jar ，aar 和class 。也就是说，所有模块需要以源码形式存在。而现在通用的做法是，将模块打包成jar或者aar，发布到Maven库，再由其他模块自行引用。</strong></p><p>有没有办法将APT的这种功能和特性延伸到jar和aar呢？<br>于是，ToyBricks应运而生。</p><h2 id="ToyBricks简介"><a href="#ToyBricks简介" class="headerlink" title="ToyBricks简介"></a>ToyBricks简介</h2><h3 id="ToyBricks简介-1"><a href="#ToyBricks简介-1" class="headerlink" title="ToyBricks简介"></a>ToyBricks简介</h3><p>ToyBricks是一个Android项目模块化的解决方案，主要包括四个部分，APT注解，APT注解处理器，ToyBricks插件（Gradle Plugin）,ToyBricks库。</p><img src="/2017/05/03/ToyBricks-Introduction/ToyBricks.svg" title="[ToyBricks]"><p>其中：</p><ol><li>APT注解，主要定义了两个注解：Interface（接口，例如：IText）,Implementation （实现，例如：TextImpl）</li><li>APT注解处理器，在javac编译java源码之前。APT注解处理器会扫描Java源码中带有上面两个注解的接口和类，并且生成一个json文件， ToyBricks.json.</li><li>ToyBricks插件（Gradle Plugin）,负责ToyBricks.json的打包，合并，生成Java源文件等工作</li><li>ToyBricks，提供对外调用方法。通过参数传入接口，返回相应的实现。</li></ol><h2 id="ToyBricks原理分析"><a href="#ToyBricks原理分析" class="headerlink" title="ToyBricks原理分析"></a>ToyBricks原理分析</h2><p>下面以接口IText和实现TextImpl为例，简单介绍下ToyBricks原理。</p><p>主要分为两个部分：</p><h3 id="Android-Library（最终可能打包成jar，aar，并发布到maven库）"><a href="#Android-Library（最终可能打包成jar，aar，并发布到maven库）" class="headerlink" title="Android Library（最终可能打包成jar，aar，并发布到maven库）"></a>Android Library（最终可能打包成jar，aar，并发布到maven库）</h3><p>如果工程是Android库模块，则主要流程如下：<br>1.在javac编译java源码之前，由APT注解处理器扫描Java源码中带有上面两个注解的接口和类，生成ToyBricks.json。</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"interfaceList"</span> : [ <span class="string">"com.github.snowdream.toybricks.app.IText"</span> ],</span><br><span class="line">  <span class="attr">"globalImplementation"</span> : &#123;</span><br><span class="line">    <span class="attr">"com.github.snowdream.toybricks.app.IText"</span> : <span class="string">"com.github.snowdream.toybricks.app.impl.NewTextGobalImpl"</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">"defaultImplementation"</span> : &#123;</span><br><span class="line">    <span class="attr">"com.github.snowdream.toybricks.app.IText"</span> : <span class="string">"com.github.snowdream.toybricks.app.impl.TextImpl"</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">"singletonImplementation"</span> : [ <span class="string">"com.github.snowdream.toybricks.app.impl.NewTextGobalImpl"</span> ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2.在打包jar，aar的时候，由ToyBricks插件（Gradle Plugin）提前处理，保证ToyBricks.json能被拷贝进去jar包或者aar包的根目录下，并随同一起分布到maven仓库。</p><h3 id="Android-Application"><a href="#Android-Application" class="headerlink" title="Android Application"></a>Android Application</h3><p>如果工程是Android应用模块，则主要流程如下：      </p><ol><li>第一步，和Android Library第一步一致。</li><li>Javac编译Java源代码</li><li>扫描所有依赖的库文件，过滤出所有包含ToyBricks.json文件的jar包或者aar包，并且提取出来。提取完毕后，合并所有的ToyBricks.json文件，成为一个ToyBricks.json。</li><li>将最终的ToyBricks.json按照预定规则生成一个Java源码文件.文件名为： InterfaceLoaderImpl.java</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.github.snowdream.toybricks.annotation.impl;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.github.snowdream.toybricks.annotation.InterfaceLoader;</span><br><span class="line"><span class="keyword">import</span> java.lang.Class;</span><br><span class="line"><span class="keyword">import</span> java.lang.Override;</span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Created by snowdream</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * This file is automatically generated by apt(Annotation Processing Tool)</span></span><br><span class="line"><span class="comment"> * Do not modify this file -- YOUR CHANGES WILL BE ERASED!</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * This file should *NOT* be checked into Version Control Systems,</span></span><br><span class="line"><span class="comment"> * as it contains information specific to your local configuration.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">InterfaceLoaderImpl</span> <span class="keyword">implements</span> <span class="title">InterfaceLoader</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> HashMap&lt;Class, Object&gt; sSingletonMap = <span class="keyword">new</span> HashMap&lt;Class, Object&gt;();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> HashMap&lt;Class, Class&gt; sGlobalMap = <span class="keyword">new</span> HashMap&lt;Class, Class&gt;();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> HashMap&lt;Class, Class&gt; sDefaultMap = <span class="keyword">new</span> HashMap&lt;Class, Class&gt;();</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">InterfaceLoaderImpl</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    addGlobalMap();</span><br><span class="line">    addDefaultMap();</span><br><span class="line">    addSingletonMap();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">addGlobalMap</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    sGlobalMap.put(com.github.snowdream.toybricks.app.IText.class,com.github.snowdream.toybricks.app.impl.NewTextGobalImpl.class);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">addDefaultMap</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    sDefaultMap.put(com.github.snowdream.toybricks.app.IText.class,com.github.snowdream.toybricks.app.impl.TextImpl.class);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">addSingletonMap</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    sSingletonMap.put(com.github.snowdream.toybricks.app.impl.NewTextGobalImpl.class,<span class="keyword">null</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> &lt;T&gt; <span class="function">T <span class="title">getImplementation</span><span class="params">(Class&lt;T&gt; clazz)</span> </span>&#123;</span><br><span class="line">    T implementation = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">boolean</span> isSingleton = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    Class implClass;</span><br><span class="line"></span><br><span class="line">    implClass = sGlobalMap.get(clazz);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (implClass == <span class="keyword">null</span>) &#123;</span><br><span class="line">      implClass = sDefaultMap.get(clazz);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (implClass != <span class="keyword">null</span>) &#123;</span><br><span class="line">      isSingleton = sSingletonMap.containsKey(implClass);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (isSingleton) &#123;</span><br><span class="line">        implementation = (T) sSingletonMap.get(implClass);</span><br><span class="line">        <span class="keyword">if</span> (implementation != <span class="keyword">null</span>) &#123;</span><br><span class="line">          <span class="keyword">return</span> implementation;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        implementation = (T) implClass.newInstance();</span><br><span class="line">      &#125; <span class="keyword">catch</span> (InstantiationException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">      &#125; <span class="keyword">catch</span> (IllegalAccessException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (isSingleton &amp;&amp; implementation != <span class="keyword">null</span>) &#123;</span><br><span class="line">        sSingletonMap.put(implClass, implementation);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> implementation;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>5.再次使用Javac工具编译InterfaceLoaderImpl.java文件。<br>6.这个文件就类似字典索引，通过这个文件，就可以通过传入接口，来查找对应的实现类。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>与APT工具相比，ToyBricks能够将接口和实现之间的关系进行持久化，存储在jar和aar中，并随之发布到Maven仓库，实现接口和实现的彻底分离。</p><p>如果您对ToyBricks有什么问题或者建议，欢迎通过后面的联系方式联系我。</p><h2 id="参考资料："><a href="#参考资料：" class="headerlink" title="参考资料："></a>参考资料：</h2><ol><li><a href="https://github.com/SnowdreamFramework/ToyBricks" target="_blank" rel="noopener">SnowdreamFramework/ToyBricks</a></li><li><a href="http://docs.oracle.com/javase/7/docs/technotes/guides/apt/" target="_blank" rel="noopener">Annotation Processing Tool (apt)</a></li><li><a href="http://hannesdorfmann.com/annotation-processing/annotationprocessing101" target="_blank" rel="noopener">ANNOTATION PROCESSING 101</a></li><li><a href="http://www.open-open.com/lib/view/open1470735314518.html" target="_blank" rel="noopener">Annotation-Processing-Tool详解</a></li><li><a href="https://race604.com/annotation-processing/" target="_blank" rel="noopener">Java注解处理器</a></li><li><a href="http://www.cnblogs.com/robnetcn/archive/2012/04/15/2449008.html" target="_blank" rel="noopener">什么是高内聚、低耦合？</a></li></ol><h2 id="联系方式"><a href="#联系方式" class="headerlink" title="联系方式"></a>联系方式</h2><ul><li>Email：yanghui1986527#gmail.com</li><li>Github: <a href="https://github.com/snowdream" target="_blank" rel="noopener">https://github.com/snowdream</a></li><li>Blog: <a href="http://snowdream.github.io/blog/" target="_blank" rel="noopener">http://snowdream.github.io/blog/</a></li><li>简书：<a href="http://www.jianshu.com/u/748f0f7e6432" target="_blank" rel="noopener">http://www.jianshu.com/u/748f0f7e6432</a></li><li>云栖博客：<a href="https://yq.aliyun.com/u/snowdream86" target="_blank" rel="noopener">https://yq.aliyun.com/u/snowdream86</a> </li><li>QQ群: 529327615     </li><li>微信公众号:  sn0wdr1am    </li></ul><p><img src="https://static.dingtalk.com/media/lADOmAwFCs0BAs0BAg_258_258.jpg" alt="sn0wdr1am"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;ToyBricks背景&quot;&gt;&lt;a href=&quot;#ToyBricks背景&quot; class=&quot;headerlink&quot; title=&quot;ToyBricks背景&quot;&gt;&lt;/a&gt;ToyBricks背景&lt;/h2&gt;&lt;p&gt;我始终认为，在高内聚，低耦合的原则下，进行组件化，模块化，插件化都是
      
    
    </summary>
    
      <category term="android" scheme="http://www.snowdream.tech/categories/android/"/>
    
    
      <category term="android" scheme="http://www.snowdream.tech/tags/android/"/>
    
  </entry>
  
  <entry>
    <title>Gradle精选: 为所有的构建启用构建缓存</title>
    <link href="http://www.snowdream.tech/2017/04/14/gradle-goodness-enable-build-cache-for/"/>
    <id>http://www.snowdream.tech/2017/04/14/gradle-goodness-enable-build-cache-for/</id>
    <published>2017-04-14T14:07:57.000Z</published>
    <updated>2018-04-19T02:49:42.027Z</updated>
    
    <content type="html"><![CDATA[<p>原文：<a href="http://mrhaki.blogspot.com/2017/04/gradle-goodness-enable-build-cache-for.html" target="_blank" rel="noopener">http://mrhaki.blogspot.com/2017/04/gradle-goodness-enable-build-cache-for.html</a></p><p>Gradle 3.5 引入了构建缓存特性。通过构建缓存，我们可以在不同的电脑之间，不同的builds之间，共享Task输出结果。举个例子，持续集成服务器上构建的输出，可以在开发者的电脑上复用。要启用这项特性，我们只需要添加命令行选项<code>--build-cache</code>。或者，我们还可以我们工程下的<code>gradle.properties</code>文件中，将<code>org.gradle.caching</code>属性设置为true。为了对所有工程都启用构建缓存特性，我们可以在Gradle主目录下的<code>gradle.properties</code>文件（ USER_HOME/.gradle/gradle.properties）中设置这个属性。</p><p>在下面的例子中，我们在<code>~/.gradle/gradle.properties</code>文件中设置<code>org.gradle.caching</code>属性：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># File: ~/.gradle/gradle.properties</span><br><span class="line">org.gradle.caching=true</span><br></pre></td></tr></table></figure></p><p>如果我们想禁用这项特性，我们可以添加命令行选项<code>--no-build-cache</code>。</p><p>基于 Gradle 3.5 编写。</p><h2 id="联系方式"><a href="#联系方式" class="headerlink" title="联系方式"></a>联系方式</h2><ul><li>Email：yanghui1986527#gmail.com</li><li>Github: <a href="https://github.com/snowdream" target="_blank" rel="noopener">https://github.com/snowdream</a></li><li>Blog: <a href="http://snowdream.github.io/blog/" target="_blank" rel="noopener">http://snowdream.github.io/blog/</a></li><li>简书：<a href="http://www.jianshu.com/u/748f0f7e6432" target="_blank" rel="noopener">http://www.jianshu.com/u/748f0f7e6432</a></li><li>云栖博客：<a href="https://yq.aliyun.com/u/snowdream86" target="_blank" rel="noopener">https://yq.aliyun.com/u/snowdream86</a> </li><li>QQ群: 529327615     </li><li>微信公众号:  sn0wdr1am    </li></ul><p><img src="https://static.dingtalk.com/media/lADOmAwFCs0BAs0BAg_258_258.jpg" alt="sn0wdr1am"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;原文：&lt;a href=&quot;http://mrhaki.blogspot.com/2017/04/gradle-goodness-enable-build-cache-for.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;http://mrhaki.
      
    
    </summary>
    
      <category term="gradle" scheme="http://www.snowdream.tech/categories/gradle/"/>
    
    
      <category term="gradle" scheme="http://www.snowdream.tech/tags/gradle/"/>
    
  </entry>
  
  <entry>
    <title>Gradle精选: 忽略Up-to-date检查，强制执行Task</title>
    <link href="http://www.snowdream.tech/2017/04/11/gradle-goodness-run-task-ignoring-up-to/"/>
    <id>http://www.snowdream.tech/2017/04/11/gradle-goodness-run-task-ignoring-up-to/</id>
    <published>2017-04-11T13:01:48.000Z</published>
    <updated>2018-04-19T02:49:42.027Z</updated>
    
    <content type="html"><![CDATA[<p>原文：<a href="http://mrhaki.blogspot.com/2016/12/gradle-goodness-run-task-ignoring-up-to.html" target="_blank" rel="noopener">http://mrhaki.blogspot.com/2016/12/gradle-goodness-run-task-ignoring-up-to.html</a></p><p>Gradle构建很快，是因为支持增量任务。简单来说，Gradle可以在运行Task前，就知道Task的输入和输出是否改变。如果什么都没有改变，那么这个Task将会被标记为up-to-date，并且不会被执行，否则则会被执行。如果不管一个Task是否是up-to-date，我们都希望能够运行它，此时我们需要增加一个命令行选项<code>--rerun-tasks</code>。</p><p>在下面的例子中，我们为一个简单的Java工程，运行assemble任务，可以看到所有的task都运行了。当我们再次运行此Task的时候，我们看到所有的task都提示“up-to-date”：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">$ gradle assemble</span><br><span class="line"> </span><br><span class="line">:compileJava</span><br><span class="line">:processResources</span><br><span class="line">:classes</span><br><span class="line">:jar</span><br><span class="line">:assemble</span><br><span class="line"> </span><br><span class="line">BUILD SUCCESSFUL</span><br><span class="line"> </span><br><span class="line">Total time: 1.765 secs</span><br><span class="line">$ gradle assemble</span><br><span class="line"> </span><br><span class="line">:compileJava UP-TO-DATE</span><br><span class="line">:processResources UP-TO-DATE</span><br><span class="line">:classes UP-TO-DATE</span><br><span class="line">:jar UP-TO-DATE</span><br><span class="line">:assemble UP-TO-DATE</span><br><span class="line"> </span><br><span class="line">BUILD SUCCESSFUL</span><br><span class="line"> </span><br><span class="line">Total time: 0.715 secs</span><br><span class="line">$</span><br></pre></td></tr></table></figure></p><p>为了忽略up-to-date检查，强制执行所有task，我们需要添加这个选项 –rerun-tasks：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">$ gradle --rerun-tasks assemble</span><br><span class="line">:compileJava</span><br><span class="line">:processResources</span><br><span class="line">:classes</span><br><span class="line">:jar</span><br><span class="line">:assemble</span><br><span class="line"> </span><br><span class="line">BUILD SUCCESSFUL</span><br><span class="line"> </span><br><span class="line">Total time: 1.037 secs</span><br><span class="line">$</span><br></pre></td></tr></table></figure></p><p>基于Gradle 3.2.1编写。</p><h2 id="联系方式"><a href="#联系方式" class="headerlink" title="联系方式"></a>联系方式</h2><ul><li>Email：yanghui1986527#gmail.com</li><li>Github: <a href="https://github.com/snowdream" target="_blank" rel="noopener">https://github.com/snowdream</a></li><li>Blog: <a href="http://snowdream.github.io/blog/" target="_blank" rel="noopener">http://snowdream.github.io/blog/</a></li><li>简书：<a href="http://www.jianshu.com/u/748f0f7e6432" target="_blank" rel="noopener">http://www.jianshu.com/u/748f0f7e6432</a></li><li>云栖博客：<a href="https://yq.aliyun.com/u/snowdream86" target="_blank" rel="noopener">https://yq.aliyun.com/u/snowdream86</a> </li><li>QQ群: 529327615     </li><li>微信公众号:  sn0wdr1am    </li></ul><p><img src="https://static.dingtalk.com/media/lADOmAwFCs0BAs0BAg_258_258.jpg" alt="sn0wdr1am"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;原文：&lt;a href=&quot;http://mrhaki.blogspot.com/2016/12/gradle-goodness-run-task-ignoring-up-to.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;http://mrhaki
      
    
    </summary>
    
      <category term="gradle" scheme="http://www.snowdream.tech/categories/gradle/"/>
    
    
      <category term="gradle" scheme="http://www.snowdream.tech/tags/gradle/"/>
    
  </entry>
  
  <entry>
    <title>Gradle精选: 在构建脚本中检测操作系统</title>
    <link href="http://www.snowdream.tech/2017/04/09/gradle-goodness-check-operating-system/"/>
    <id>http://www.snowdream.tech/2017/04/09/gradle-goodness-check-operating-system/</id>
    <published>2017-04-09T16:15:27.000Z</published>
    <updated>2018-04-19T02:49:42.027Z</updated>
    
    <content type="html"><![CDATA[<p>原文： <a href="http://mrhaki.blogspot.com/2017/02/gradle-goodness-check-operating-system.html" target="_blank" rel="noopener">http://mrhaki.blogspot.com/2017/02/gradle-goodness-check-operating-system.html</a></p><p>有时候，我们想检测下构建脚本在哪个操作系统上执行。举个例子，比如我们有一些Task，需要在Windows操作系统上执行，但是不在其他操作系统上执行。Gradle有一个内部的类<code>org.gradle.nativeplatform.platform.internal.DefaultOperatingSystem</code>，但是我们不应该在构建脚本中使用这个类。Gradle在内部使用这个类，并且可能毫无警告地修改它。如果我们依赖这个类，一旦这个类被修改了，我们的构建脚本可能无法正常运行。但是，我们可以使用一个来自Ant的类（<code>org.apache.tools.ant.taskdefs.condition.Os</code>）。这个类包含各种方法和变量，来检测操作系统名称，版本和架构。 这些取值都基于Java的系统变量，包括os.name, os.version 和 os.arch.</p><p>在下面的例子中，为了我们稍后能够直接调用这个类的方法和引用这个类的常量，我们在构建脚本中静态引入这个Os类。 我们添加了几个基于onlyif条件的Task。只有当onlyif条件为true时，Task才会被执行。Task osInfo则简单显示了当前操作系统的一些属性值：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">// File: build.gradle</span><br><span class="line">import static org.apache.tools.ant.taskdefs.condition.Os.*</span><br><span class="line"> </span><br><span class="line">task os &#123;</span><br><span class="line">    description &apos;Run all conditional os tasks&apos;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">// Create 3 tasks that simply print</span><br><span class="line">// the task name that is executed</span><br><span class="line">// if the build scripts runs on the</span><br><span class="line">// recognized operating system.</span><br><span class="line">[FAMILY_WINDOWS, FAMILY_UNIX, FAMILY_MAC].each &#123; osName -&gt;</span><br><span class="line"> </span><br><span class="line">    // Create task.</span><br><span class="line">    tasks.create(osName) &#123;</span><br><span class="line">        description &quot;Run when OS is $&#123;osName&#125;&quot;</span><br><span class="line"> </span><br><span class="line">        // Add condition to check operating system.</span><br><span class="line">        onlyIf &#123; isFamily(osName) &#125;</span><br><span class="line"> </span><br><span class="line">        doLast &#123;</span><br><span class="line">            println &quot;Execute task &apos;$&#123;it.name&#125;&apos;&quot;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    // Add task as dependency for the os task.</span><br><span class="line">    os.dependsOn osName</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">task osInfo &#123;</span><br><span class="line">    description &apos;Show information about the operating system&apos;</span><br><span class="line">    doLast &#123;</span><br><span class="line">        println &quot;Family:       $&#123;OS_NAME&#125;&quot;</span><br><span class="line">        println &quot;Version:      $&#123;OS_VERSION&#125;&quot;</span><br><span class="line">        println &quot;Architecture: $&#123;OS_ARCH&#125;&quot;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来，让我们在MacOS上运行这些Task： os and osInfo<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">$ gradle os osInfo</span><br><span class="line">mac</span><br><span class="line">Execute task &apos;mac&apos;</span><br><span class="line">:unix</span><br><span class="line">Execute task &apos;unix&apos;</span><br><span class="line">:windows SKIPPED</span><br><span class="line">:os</span><br><span class="line">:osInfo</span><br><span class="line">Family:       mac os x</span><br><span class="line">Version:      10.12.3</span><br><span class="line">Architecture: x86_64</span><br><span class="line"> </span><br><span class="line">BUILD SUCCESSFUL</span><br><span class="line"> </span><br><span class="line">Total time: 0.697 secs</span><br></pre></td></tr></table></figure></p><p>基于Gradle 3.3编写。</p><h2 id="联系方式"><a href="#联系方式" class="headerlink" title="联系方式"></a>联系方式</h2><ul><li>Email：yanghui1986527#gmail.com</li><li>Github: <a href="https://github.com/snowdream" target="_blank" rel="noopener">https://github.com/snowdream</a></li><li>Blog: <a href="http://snowdream.github.io/blog/" target="_blank" rel="noopener">http://snowdream.github.io/blog/</a></li><li>简书：<a href="http://www.jianshu.com/u/748f0f7e6432" target="_blank" rel="noopener">http://www.jianshu.com/u/748f0f7e6432</a></li><li>云栖博客：<a href="https://yq.aliyun.com/u/snowdream86" target="_blank" rel="noopener">https://yq.aliyun.com/u/snowdream86</a> </li><li>QQ群: 529327615     </li><li>微信公众号:  sn0wdr1am    </li></ul><p><img src="https://static.dingtalk.com/media/lADOmAwFCs0BAs0BAg_258_258.jpg" alt="sn0wdr1am"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;原文： &lt;a href=&quot;http://mrhaki.blogspot.com/2017/02/gradle-goodness-check-operating-system.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;http://mrhaki
      
    
    </summary>
    
      <category term="gradle" scheme="http://www.snowdream.tech/categories/gradle/"/>
    
    
      <category term="gradle" scheme="http://www.snowdream.tech/tags/gradle/"/>
    
  </entry>
  
  <entry>
    <title>Gradle精选: 当输入为空时，使用注解@SkipWhenEmpty来跳过Task</title>
    <link href="http://www.snowdream.tech/2017/04/09/gradle-goodness-skip-task-when-input/"/>
    <id>http://www.snowdream.tech/2017/04/09/gradle-goodness-skip-task-when-input/</id>
    <published>2017-04-09T15:39:37.000Z</published>
    <updated>2018-04-19T02:49:42.027Z</updated>
    
    <content type="html"><![CDATA[<p>原文： <a href="http://mrhaki.blogspot.com/2017/02/gradle-goodness-skip-task-when-input.html" target="_blank" rel="noopener">http://mrhaki.blogspot.com/2017/02/gradle-goodness-skip-task-when-input.html</a></p><p>Gradle 能够很好的支持增量构建。这就是说，Gradle可以根据Task的输入和输出来决定一个Task是否需要被执行。举个例子，假如输入和输出文件没有任何改变，那么这个Task将会被跳过。通过定义Task的输入和输出，可以让我们自定义的Task也支持增量构建。我们还可以定义一个Task，当它的输入文件集合／文件夹不存在或者为空时，跳过不执行。Gradle提供了一个注解@SkipWhenEmpty，我们可以应用于Task的输入。</p><p>下面的例子，我们将会定义一个DisplayTask，用于打印一个文件夹下所有文件的内容。当这个文件夹为空时，我们希望跳过这个Task，不执行。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">task display(type:DisplayTask) &#123;</span><br><span class="line">    contentDir = file(&apos;src/content&apos;)</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">class DisplayTask extends DefaultTask &#123;</span><br><span class="line"> </span><br><span class="line">    @SkipWhenEmpty</span><br><span class="line">    @InputDirectory</span><br><span class="line">    File contentDir</span><br><span class="line"> </span><br><span class="line">    DisplayTask() &#123;</span><br><span class="line">        description = &apos;Show contents of files&apos;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    @TaskAction</span><br><span class="line">    void printMessages() &#123;</span><br><span class="line">        contentDir.eachFile &#123; file -&gt;</span><br><span class="line">            println file.text</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当输入文件夹下没有任何文件时，我们运行这个Task，将会在终端看到 NO-SOURCE 字样。如果我们不添加这个注解@SkipWhenEmpty，这个构建任务将会失败。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ gradle display</span><br><span class="line">:display NO-SOURCE</span><br><span class="line"> </span><br><span class="line">BUILD SUCCESSFUL</span><br><span class="line"> </span><br><span class="line">Total time: 0.866 secs</span><br></pre></td></tr></table></figure><p>接下来，我们在这个文件夹（src/content）下添加一个文件，然后再次运行这个Task：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ gradle display</span><br><span class="line">:display</span><br><span class="line">Gradle rocks!</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">BUILD SUCCESSFUL</span><br><span class="line"> </span><br><span class="line">Total time: 0.866 secs</span><br></pre></td></tr></table></figure></p><p>使用Gradle 3.4编写。</p><h2 id="联系方式"><a href="#联系方式" class="headerlink" title="联系方式"></a>联系方式</h2><ul><li>Email：yanghui1986527#gmail.com</li><li>Github: <a href="https://github.com/snowdream" target="_blank" rel="noopener">https://github.com/snowdream</a></li><li>Blog: <a href="http://snowdream.github.io/blog/" target="_blank" rel="noopener">http://snowdream.github.io/blog/</a></li><li>简书：<a href="http://www.jianshu.com/u/748f0f7e6432" target="_blank" rel="noopener">http://www.jianshu.com/u/748f0f7e6432</a></li><li>云栖博客：<a href="https://yq.aliyun.com/u/snowdream86" target="_blank" rel="noopener">https://yq.aliyun.com/u/snowdream86</a> </li><li>QQ群: 529327615     </li><li>微信公众号:  sn0wdr1am    </li></ul><p><img src="https://static.dingtalk.com/media/lADOmAwFCs0BAs0BAg_258_258.jpg" alt="sn0wdr1am"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;原文： &lt;a href=&quot;http://mrhaki.blogspot.com/2017/02/gradle-goodness-skip-task-when-input.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;http://mrhaki.b
      
    
    </summary>
    
      <category term="gradle" scheme="http://www.snowdream.tech/categories/gradle/"/>
    
    
      <category term="gradle" scheme="http://www.snowdream.tech/tags/gradle/"/>
    
  </entry>
  
  <entry>
    <title>Gradle精选: 在IntellIJ IDEA中创建快捷方式，用于刷新Gradle工程</title>
    <link href="http://www.snowdream.tech/2017/03/28/gradle-goodness-create-shortcut-key-to/"/>
    <id>http://www.snowdream.tech/2017/03/28/gradle-goodness-create-shortcut-key-to/</id>
    <published>2017-03-28T14:36:20.000Z</published>
    <updated>2018-04-19T02:49:42.027Z</updated>
    
    <content type="html"><![CDATA[<p>翻译自： <a href="http://mrhaki.blogspot.com/2017/03/gradle-goodness-create-shortcut-key-to.html" target="_blank" rel="noopener">http://mrhaki.blogspot.com/2017/03/gradle-goodness-create-shortcut-key-to.html</a></p><p>我们可以在IntelliJ IDEA中打开一个Gradle工程，并且获得IntelliJ对Gradle的原生支持。当我们在Gradle build文件中添加一个新的依赖或者插件时，需要在 IntelliJ IDEA中刷新工程。我们需要刷新这个Gradle工程，来保证IntelliJ IDEA 能够同步这些改变。Gradle工具栏有一个Icon，点击它可以刷新所有Gradle工程。但是这样做，意味着我们需要移动鼠标，而我们现在需要一个快捷键来完成这些操作，这样，我们就不需要把手移开键盘。</p><p>刷新所有Gradle项目的操作，实际上是刷新所有外部功能的操作。我们可以通过  Preferences | Keymap 来添加键盘快捷键。我们在搜索栏搜索“refresh all external”来找到这个动作。</p><p><img src="http://upload-images.jianshu.io/upload_images/66954-210d8142097b28fa.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="idea-refresh-gradle-keymap.png"></p><p>我们可以右键点击这个Action，然后选择“Keyboard Shortcut”来定义新的键盘快捷键。</p><p>现在当我们修改Gradle build文件时，我们可以简单的使用快捷键来刷新Gradle工程。</p><p>下面我们介绍如何将这个刷新Gradle工程的Action添加到工具栏。右键点击工具栏，并且选择“option Customize Menus and Toolbars…. ”。现在可以将”Refresh all external projects”添加到工具栏：</p><p><img src="http://upload-images.jianshu.io/upload_images/66954-6ec3b83690e2f4ab.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="idea-refresh-gradle-keymap-assign.png"></p><h2 id="联系方式"><a href="#联系方式" class="headerlink" title="联系方式"></a>联系方式</h2><ul><li>Email：yanghui1986527#gmail.com</li><li>Github: <a href="https://github.com/snowdream" target="_blank" rel="noopener">https://github.com/snowdream</a></li><li>Blog: <a href="http://snowdream.github.io/blog/" target="_blank" rel="noopener">http://snowdream.github.io/blog/</a></li><li>简书：<a href="http://www.jianshu.com/u/748f0f7e6432" target="_blank" rel="noopener">http://www.jianshu.com/u/748f0f7e6432</a></li><li>云栖博客：<a href="https://yq.aliyun.com/u/snowdream86" target="_blank" rel="noopener">https://yq.aliyun.com/u/snowdream86</a> </li><li>QQ群: 529327615     </li><li>微信公众号:  sn0wdr1am    </li></ul><p><img src="https://static.dingtalk.com/media/lADOmAwFCs0BAs0BAg_258_258.jpg" alt="sn0wdr1am"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;翻译自： &lt;a href=&quot;http://mrhaki.blogspot.com/2017/03/gradle-goodness-create-shortcut-key-to.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;http://mrhak
      
    
    </summary>
    
      <category term="gradle" scheme="http://www.snowdream.tech/categories/gradle/"/>
    
    
      <category term="gradle" scheme="http://www.snowdream.tech/tags/gradle/"/>
    
  </entry>
  
  <entry>
    <title>Gradle精选: 运行单个单元测试</title>
    <link href="http://www.snowdream.tech/2017/03/27/gradle-goodness-running-single-test/"/>
    <id>http://www.snowdream.tech/2017/03/27/gradle-goodness-running-single-test/</id>
    <published>2017-03-27T13:53:17.000Z</published>
    <updated>2018-04-19T02:49:42.027Z</updated>
    
    <content type="html"><![CDATA[<p>在Gradle下，我们可以通过由Java插件添加的测试任务，来运行单元测试代码。默认情况下，项目下的所有单元测试代码都会执行。但是，如果我们只想运行一个简单的单元测试，我们可以通过Java系统属性test.single来制定这个单元测试的名字。实际上，系统属性的样式是<code>taskName.single</code>. 其中<code>taskName</code>是项目下测试类任务的名称。下面我们将展示在构建中如何实践的：</p><p>首先，我们创建一个简单的build.gradle文件，用来运行单元测试。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">// File: build.gradle</span><br><span class="line">apply plugin: &apos;java&apos;</span><br><span class="line"> </span><br><span class="line">repositories &#123;</span><br><span class="line">    mavenCentral()</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">dependencies &#123;</span><br><span class="line">    testCompile &apos;junit:junit:[4,)&apos;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">test &#123;</span><br><span class="line">    testLogging &#123;</span><br><span class="line">        // Show that tests are run in the command-line output</span><br><span class="line">        events &apos;started&apos;, &apos;passed&apos;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>下一步，我们创建两个测试类，每个测试类包含一个简单的单元测试方法。稍后，我们会演示，如何运行其中的一个单元测试。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">// File: src/test/java/com/mrhaki/gradle/SampleTest.java</span><br><span class="line">package com.mrhaki.gradle;</span><br><span class="line"> </span><br><span class="line">import static org.junit.Assert.*;</span><br><span class="line">import org.junit.*;</span><br><span class="line"> </span><br><span class="line">public class SampleTest &#123;</span><br><span class="line"> </span><br><span class="line">    @Test public void sample() &#123;</span><br><span class="line">        assertEquals(&quot;Gradle is gr8&quot;, &quot;Gradle is gr8&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">// File: src/test/java/com/mrhaki/gradle/AnotherSampleTest.java</span><br><span class="line">package com.mrhaki.gradle;</span><br><span class="line"> </span><br><span class="line">import static org.junit.Assert.*;</span><br><span class="line">import org.junit.*;</span><br><span class="line"> </span><br><span class="line">public class AnotherSampleTest &#123;</span><br><span class="line"> </span><br><span class="line">    @Test public void anotherSample() &#123;</span><br><span class="line">        assertEquals(&quot;Gradle is great&quot;, &quot;Gradle is great&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>为了只运行SampleTest，我们需要在终端执行test任务的时候，添加一个Java系统属性 <code>-Dtest.single=Sample</code>：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">$ gradle -Dtest.single=Sample test</span><br><span class="line">:compileJava UP-TO-DATE</span><br><span class="line">:processResources UP-TO-DATE</span><br><span class="line">:classes UP-TO-DATE</span><br><span class="line">:compileTestJava</span><br><span class="line">:processTestResources UP-TO-DATE</span><br><span class="line">:testClasses</span><br><span class="line">:test</span><br><span class="line"> </span><br><span class="line">com.mrhaki.gradle.SampleTest &gt; sample STARTED</span><br><span class="line"> </span><br><span class="line">com.mrhaki.gradle.SampleTest &gt; sample PASSED</span><br><span class="line"> </span><br><span class="line">BUILD SUCCESSFUL</span><br><span class="line"> </span><br><span class="line">Total time: 11.404 secs</span><br></pre></td></tr></table></figure></p><p>请注意，现在只有一个单元测试执行了。Gradle将会获取Sample的值，并且按照下面的样式 <code>**/&lt;Java system property value=Sample&gt;*.class</code>去查找单元测试类。因此，我们不需要输入单元测试的完整包名和类名。而为了仅仅执行AnotherSampleTest单元测试类，我们可以通过改变这个Java系统属性（test.single）来实现：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">$ gradle -Dtest.single=AnotherSample test</span><br><span class="line">:compileJava UP-TO-DATE</span><br><span class="line">:processResources UP-TO-DATE</span><br><span class="line">:classes UP-TO-DATE</span><br><span class="line">:compileTestJava</span><br><span class="line">:processTestResources UP-TO-DATE</span><br><span class="line">:testClasses UP-TO-DATE</span><br><span class="line">:test</span><br><span class="line"> </span><br><span class="line">com.mrhaki.gradle.AnotherSampleTest &gt; anotherSample STARTED</span><br><span class="line"> </span><br><span class="line">com.mrhaki.gradle.AnotherSampleTest &gt; anotherSample PASSED</span><br><span class="line"> </span><br><span class="line">BUILD SUCCESSFUL</span><br><span class="line"> </span><br><span class="line">Total time: 5.62 secs</span><br></pre></td></tr></table></figure><p>我们还可以使用Java系统样式来执行多个单元测试。例如：我们可以使用<code>*Sample</code>来同时运行 SampleTest 和A notherSampleTest。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">$ gradle -Dtest.single=*Sample test</span><br><span class="line">:compileJava UP-TO-DATE</span><br><span class="line">:processResources UP-TO-DATE</span><br><span class="line">:classes UP-TO-DATE</span><br><span class="line">:compileTestJava</span><br><span class="line">:processTestResources UP-TO-DATE</span><br><span class="line">:testClasses UP-TO-DATE</span><br><span class="line">:test</span><br><span class="line"> </span><br><span class="line">com.mrhaki.gradle.AnotherSampleTest &gt; anotherSample STARTED</span><br><span class="line"> </span><br><span class="line">com.mrhaki.gradle.AnotherSampleTest &gt; anotherSample PASSED</span><br><span class="line"> </span><br><span class="line">com.mrhaki.gradle.SampleTest &gt; sample STARTED</span><br><span class="line"> </span><br><span class="line">com.mrhaki.gradle.SampleTest &gt; sample PASSED</span><br><span class="line"> </span><br><span class="line">BUILD SUCCESSFUL</span><br><span class="line"> </span><br><span class="line">Total time: 5.605 secs</span><br></pre></td></tr></table></figure><p>为了展示对于其他类型的测试任务，这种Java系统属性都有效。我们在build.gradle 文件中添加了一个新的任务。我们命名这个测试任务为sampleTest，包含了我们所有的测试类。我们同样应用了和之前一样的testLogging设置，方便跟踪单元测试输出结果。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">// File: build.gradle</span><br><span class="line">apply plugin: &apos;java&apos;</span><br><span class="line"> </span><br><span class="line">repositories &#123;</span><br><span class="line">    mavenCentral()</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">dependencies &#123;</span><br><span class="line">    testCompile &apos;junit:junit:[4,)&apos;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">task sampleTest(type: Test, dependsOn: testClasses) &#123;</span><br><span class="line">    include &apos;**/*Sample*&apos;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">tasks.withType(Test) &#123;</span><br><span class="line">    testLogging &#123;</span><br><span class="line">        events &apos;started&apos;, &apos;passed&apos;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>下面我们值运行SampleTest测试类，但是我们换一种方式使用Java系统属性 <code>-DsampleTest.single=S*</code>:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">$ gradle -DsampleTest.single=S* sampleTest</span><br><span class="line">:compileJava UP-TO-DATE</span><br><span class="line">:processResources UP-TO-DATE</span><br><span class="line">:classes UP-TO-DATE</span><br><span class="line">:compileTestJava UP-TO-DATE</span><br><span class="line">:processTestResources UP-TO-DATE</span><br><span class="line">:testClasses UP-TO-DATE</span><br><span class="line">:sampleTest</span><br><span class="line"> </span><br><span class="line">com.mrhaki.gradle.SampleTest &gt; sample STARTED</span><br><span class="line"> </span><br><span class="line">com.mrhaki.gradle.SampleTest &gt; sample PASSED</span><br><span class="line"> </span><br><span class="line">BUILD SUCCESSFUL</span><br><span class="line"> </span><br><span class="line">Total time: 10.677 secs</span><br></pre></td></tr></table></figure></p><p>实例使用 Gradle 1.6 编写。</p><h2 id="联系方式"><a href="#联系方式" class="headerlink" title="联系方式"></a>联系方式</h2><ul><li>Email：yanghui1986527#gmail.com</li><li>Github: <a href="https://github.com/snowdream" target="_blank" rel="noopener">https://github.com/snowdream</a></li><li>Blog: <a href="http://snowdream.github.io/blog/" target="_blank" rel="noopener">http://snowdream.github.io/blog/</a></li><li>简书：<a href="http://www.jianshu.com/u/748f0f7e6432" target="_blank" rel="noopener">http://www.jianshu.com/u/748f0f7e6432</a></li><li>云栖博客：<a href="https://yq.aliyun.com/u/snowdream86" target="_blank" rel="noopener">https://yq.aliyun.com/u/snowdream86</a> </li><li>QQ群: 529327615     </li><li>微信公众号:  sn0wdr1am    </li></ul><p><img src="https://static.dingtalk.com/media/lADOmAwFCs0BAs0BAg_258_258.jpg" alt="sn0wdr1am"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在Gradle下，我们可以通过由Java插件添加的测试任务，来运行单元测试代码。默认情况下，项目下的所有单元测试代码都会执行。但是，如果我们只想运行一个简单的单元测试，我们可以通过Java系统属性test.single来制定这个单元测试的名字。实际上，系统属性的样式是&lt;co
      
    
    </summary>
    
      <category term="gradle" scheme="http://www.snowdream.tech/categories/gradle/"/>
    
    
      <category term="gradle" scheme="http://www.snowdream.tech/tags/gradle/"/>
    
  </entry>
  
  <entry>
    <title>基于Docker和Debian打造个人专属操作系统</title>
    <link href="http://www.snowdream.tech/2017/03/22/build-private-os-system-with-docker-debian-mate-x2go/"/>
    <id>http://www.snowdream.tech/2017/03/22/build-private-os-system-with-docker-debian-mate-x2go/</id>
    <published>2017-03-22T14:22:03.000Z</published>
    <updated>2018-04-19T02:49:42.023Z</updated>
    
    <content type="html"><![CDATA[<p>一提到Docker，你可能想到云服务，运维等等。<br>今天，我们要谈谈Docker的本地应用，如何基于Docker和Debian打造一款个人专属操作系统。</p><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>一个Docker镜像运行起来就相当于一个没有桌面的Linux系统。</p><p>现在，我们给一个基于Debian的Docker镜像，加上Mate桌面，就成了一个完整的Linux操作系统了。</p><p>为了保证我们可以通过网络来访问这个系统，我们再安装上OpenSSH和X2GO。</p><p>这样，一款基本的个人专属操作系统就完成了。当然，你可以在这个基础上，增加常用的软件，打造自己的个人专属操作系统。</p><h2 id="构成"><a href="#构成" class="headerlink" title="构成"></a>构成</h2><p>主要包含以下几个部分：</p><ul><li>Debian jessie</li><li>Mate Desktop</li><li>Openssh-server</li><li>X2goserver</li></ul><h2 id="下载-amp-amp-安装"><a href="#下载-amp-amp-安装" class="headerlink" title="下载 &amp;&amp; 安装"></a>下载 &amp;&amp; 安装</h2><h3 id="1-snowdream-desktop"><a href="#1-snowdream-desktop" class="headerlink" title="1. snowdream/desktop"></a>1. snowdream/desktop</h3><p>下载Docker镜像：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker pull snowdream/desktop</span><br></pre></td></tr></table></figure></p><h3 id="2-X2Go-客户端"><a href="#2-X2Go-客户端" class="headerlink" title="2. X2Go 客户端"></a>2. X2Go 客户端</h3><p>以mac为例，其他参考： <a href="http://wiki.x2go.org/doku.php/doc:installation:x2goclient" target="_blank" rel="noopener">http://wiki.x2go.org/doku.php/doc:installation:x2goclient</a></p><p>先下载安装XQuartz-2.7.11.dmg（<a href="https://www.xquartz.org）" target="_blank" rel="noopener">https://www.xquartz.org）</a></p><p>再下载安装x2goclient （<a href="https://code.x2go.org/releases/binary-macosx/x2goclient/releases/4.1.0.0/）" target="_blank" rel="noopener">https://code.x2go.org/releases/binary-macosx/x2goclient/releases/4.1.0.0/）</a></p><h2 id="运行"><a href="#运行" class="headerlink" title="运行"></a>运行</h2><h3 id="1-启动snowdream-desktop"><a href="#1-启动snowdream-desktop" class="headerlink" title="1. 启动snowdream/desktop"></a>1. 启动snowdream/desktop</h3><p>通过以下Docker命令，启动镜像。<br>请留意提示的root和dockerx用户的密码，并记录下来。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">CID=$(docker run -p 2222:22 -t -d snowdream/desktop)</span><br><span class="line">docker logs <span class="variable">$CID</span></span><br></pre></td></tr></table></figure></p><h3 id="2-通过ssh访问"><a href="#2-通过ssh访问" class="headerlink" title="2. 通过ssh访问"></a>2. 通过ssh访问</h3><p>通过以下终端命令，连接上面的镜像。<br>密码见前面的提示。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh root@localhost -p 2222</span><br></pre></td></tr></table></figure></p><h3 id="3-通过x2go访问桌面"><a href="#3-通过x2go访问桌面" class="headerlink" title="3. 通过x2go访问桌面"></a>3. 通过x2go访问桌面</h3><ol><li>启动x2go客户端</li><li>配置x2go客户端</li></ol><p>点击主界面工具栏第三个按钮，看看全局设置中，XQuartz的路径和版本是否正确。</p><p><img src="https://static.dingtalk.com/media/lALOtOPUL80CS80CZw_615_587.png" alt="配置x2go客户端"></p><p>接着，按照下面提示，创建一个会话。</p><p>其中，Host为主机IP，Login为用户名，SSH port为ssh端口，<br>底部的会话桌面选择Mate。</p><p><img src="https://static.dingtalk.com/media/lALOtOL6_s0Ctc0DIg_802_693.png" alt="配置x2go客户端"></p><p>3.启动会话，连接桌面。</p><h2 id="联系方式"><a href="#联系方式" class="headerlink" title="联系方式"></a>联系方式</h2><ul><li>Email：yanghui1986527#gmail.com</li><li>Github: <a href="https://github.com/snowdream" target="_blank" rel="noopener">https://github.com/snowdream</a></li><li>Blog: <a href="http://snowdream.github.io/blog/" target="_blank" rel="noopener">http://snowdream.github.io/blog/</a></li><li>简书：<a href="http://www.jianshu.com/u/748f0f7e6432" target="_blank" rel="noopener">http://www.jianshu.com/u/748f0f7e6432</a></li><li>云栖博客：<a href="https://yq.aliyun.com/u/snowdream86" target="_blank" rel="noopener">https://yq.aliyun.com/u/snowdream86</a> </li><li>QQ群: 529327615     </li><li>微信公众号:  sn0wdr1am    </li></ul><p><img src="https://static.dingtalk.com/media/lADOmAwFCs0BAs0BAg_258_258.jpg" alt="sn0wdr1am"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;一提到Docker，你可能想到云服务，运维等等。&lt;br&gt;今天，我们要谈谈Docker的本地应用，如何基于Docker和Debian打造一款个人专属操作系统。&lt;/p&gt;
&lt;h2 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介
      
    
    </summary>
    
      <category term="docker" scheme="http://www.snowdream.tech/categories/docker/"/>
    
    
      <category term="docker" scheme="http://www.snowdream.tech/tags/docker/"/>
    
  </entry>
  
  <entry>
    <title>Gradle精选: 关于运行失败的单元测试CASE，显示更多相关信息</title>
    <link href="http://www.snowdream.tech/2017/03/15/gradle-goodness-show-more-information/"/>
    <id>http://www.snowdream.tech/2017/03/15/gradle-goodness-show-more-information/</id>
    <published>2017-03-15T10:17:38.000Z</published>
    <updated>2018-04-19T02:49:42.027Z</updated>
    
    <content type="html"><![CDATA[<p>在Gradle中运行单元测试很简单。一般情况下，如果有一个单元测试CASE执行失败，也会导致构建失败。但是我们却不能立刻在控制台看到为什么这个单元测试失败。我们需要先打开生成的HTML格式的测试报告。现在我们还有其他办法。</p><p>首先，我们创建一个下面的Gradle build文件：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">// File: build.gradle</span><br><span class="line">apply plugin: &apos;java&apos;</span><br><span class="line"> </span><br><span class="line">repositories &#123;</span><br><span class="line">    mavenCentral()</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">dependencies &#123;</span><br><span class="line">    testCompile &apos;junit:junit:[4,)&apos;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>然后，我们使用下面的Junit单元测试。注意，这个单元测试一直会失败，因为这就是我们想要的CASE场景。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">// File: src/test/java/com/mrhaki/gradle/SampleTest.java</span><br><span class="line">package com.mrhaki.gradle;</span><br><span class="line"> </span><br><span class="line">import org.junit.*;</span><br><span class="line"> </span><br><span class="line">public class SampleTest &#123;</span><br><span class="line"> </span><br><span class="line">    @Test public void sample() &#123;</span><br><span class="line">        Assert.assertEquals(&quot;Gradle is gr8&quot;, &quot;Gradle is great&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>我们通过执行test任务，来运行单元测试。如果我们运行这个任务，我们发现控制台显示哪一行单元测试失败了，但是我们却看不到单元测试失败的具体原因:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">$ gradle test</span><br><span class="line">:compileJava UP-TO-DATE</span><br><span class="line">:processResources UP-TO-DATE</span><br><span class="line">:classes UP-TO-DATE</span><br><span class="line">:compileTestJava</span><br><span class="line">:processTestResources UP-TO-DATE</span><br><span class="line">:testClasses</span><br><span class="line">:test</span><br><span class="line"> </span><br><span class="line">com.mrhaki.gradle.SampleTest &gt; sample FAILED</span><br><span class="line">    org.junit.ComparisonFailure at SampleTest.java:8</span><br><span class="line"> </span><br><span class="line">1 test completed, 1 failed</span><br><span class="line">:test FAILED</span><br><span class="line"> </span><br><span class="line">FAILURE: Build failed with an exception.</span><br><span class="line"> </span><br><span class="line">* What went wrong:</span><br><span class="line">Execution failed for task &apos;:test&apos;.</span><br><span class="line">&gt; There were failing tests. See the report at: file:///Users/mrhaki/Projects/mrhaki.com/blog/posts/samples/gradle/testlogging/build/reports/tests/index.html</span><br><span class="line"> </span><br><span class="line">* Try:</span><br><span class="line">Run with --stacktrace option to get the stack trace. Run with --info or --debug option to get more log output.</span><br><span class="line"> </span><br><span class="line">BUILD FAILED</span><br><span class="line"> </span><br><span class="line">Total time: 4.904 secs</span><br></pre></td></tr></table></figure></p><p>我们可以再次运行test任务，但是现在我们通过添加命令行选项-i 或者 –info来设置Gradle日志级别到info。现在我们可以在终端看到单元测试失败的具体原因了。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">$ gradle test -i</span><br><span class="line">Starting Build</span><br><span class="line">Settings evaluated using empty settings script.</span><br><span class="line">Projects loaded. Root project using build file</span><br><span class="line">...</span><br><span class="line">Successfully started process &apos;Gradle Worker 1&apos;</span><br><span class="line">Gradle Worker 1 executing tests.</span><br><span class="line">Gradle Worker 1 finished executing tests.</span><br><span class="line"> </span><br><span class="line">com.mrhaki.gradle.SampleTest &gt; sample FAILED</span><br><span class="line">    org.junit.ComparisonFailure: expected:&lt;gradle is gr[8]&gt; but was:&lt;gradle is gr[eat]&gt;</span><br><span class="line">        at org.junit.Assert.assertEquals(Assert.java:115)</span><br><span class="line">        at org.junit.Assert.assertEquals(Assert.java:144)</span><br><span class="line">        at com.mrhaki.gradle.SampleTest.sample(SampleTest.java:8)</span><br><span class="line">Process &apos;Gradle Worker 1&apos; finished with exit value 0 (state: SUCCEEDED)</span><br><span class="line"> </span><br><span class="line">1 test completed, 1 failed</span><br><span class="line">Finished generating test XML results (0.025 secs)</span><br><span class="line">Generating HTML test report...</span><br><span class="line">Finished generating test html results (0.027 secs)</span><br><span class="line">:test FAILED</span><br><span class="line"> </span><br><span class="line">FAILURE: Build failed with an exception.</span><br><span class="line"> </span><br><span class="line">* What went wrong:</span><br><span class="line">Execution failed for task &apos;:test&apos;.</span><br><span class="line">&gt; There were failing tests. See the report at: file:///Users/mrhaki/Projects/mrhaki.com/blog/posts/samples/gradle/testlogging/build/reports/tests/index.html</span><br><span class="line"> </span><br><span class="line">* Try:</span><br><span class="line">Run with --stacktrace option to get the stack trace. Run with --debug option to get more log output.</span><br><span class="line"> </span><br><span class="line">BUILD FAILED</span><br><span class="line"> </span><br><span class="line">Total time: 5.117 secs</span><br></pre></td></tr></table></figure></p><p>但是这样做仍然会产生很多干扰的日志。最好的办法就是通过配置test任务来自定义单元测试日志级别。我们可以配置不同的日志级别。为了获取单元测试失败的具体原因我们可以仅仅将exceptionFormat设置为full。示例如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">// File: build.gradle</span><br><span class="line">apply plugin: &apos;java&apos;</span><br><span class="line"> </span><br><span class="line">repositories &#123;</span><br><span class="line">    mavenCentral()</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">dependencies &#123;</span><br><span class="line">    testCompile &apos;junit:junit:[4,)&apos;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">test &#123;</span><br><span class="line">    testLogging &#123;</span><br><span class="line">        exceptionFormat = &apos;full&apos;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>我们可以再次运行test任务，并且使用正常的日志级别，但是这次，我们依然能够看到单元测试失败的具体原因，而没有其他的干扰日志。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">$ gradle test</span><br><span class="line">:compileJava UP-TO-DATE</span><br><span class="line">:processResources UP-TO-DATE</span><br><span class="line">:classes UP-TO-DATE</span><br><span class="line">:compileTestJava UP-TO-DATE</span><br><span class="line">:processTestResources UP-TO-DATE</span><br><span class="line">:testClasses UP-TO-DATE</span><br><span class="line">:test</span><br><span class="line"> </span><br><span class="line">com.mrhaki.gradle.SampleTest &gt; sample FAILED</span><br><span class="line">    org.junit.ComparisonFailure: expected:&lt;gradle is gr[8]&gt; but was:&lt;gradle is gr[eat]&gt;</span><br><span class="line">        at org.junit.Assert.assertEquals(Assert.java:115)</span><br><span class="line">        at org.junit.Assert.assertEquals(Assert.java:144)</span><br><span class="line">        at com.mrhaki.gradle.SampleTest.sample(SampleTest.java:8)</span><br><span class="line"> </span><br><span class="line">1 test completed, 1 failed</span><br><span class="line">:test FAILED</span><br><span class="line"> </span><br><span class="line">FAILURE: Build failed with an exception.</span><br><span class="line"> </span><br><span class="line">* What went wrong:</span><br><span class="line">Execution failed for task &apos;:test&apos;.</span><br><span class="line">&gt; There were failing tests. See the report at: file:///Users/mrhaki/Projects/mrhaki.com/blog/posts/samples/gradle/testlogging/build/reports/tests/index.html</span><br><span class="line"> </span><br><span class="line">* Try:</span><br><span class="line">Run with --stacktrace option to get the stack trace. Run with --info or --debug option to get more log output.</span><br><span class="line"> </span><br><span class="line">BUILD FAILED</span><br><span class="line"> </span><br><span class="line">Total time: 5.906 secs</span><br></pre></td></tr></table></figure></p><p>实例使用 Gradle 1.6 编写。</p><h2 id="联系方式"><a href="#联系方式" class="headerlink" title="联系方式"></a>联系方式</h2><ul><li>Email：yanghui1986527#gmail.com</li><li>Github: <a href="https://github.com/snowdream" target="_blank" rel="noopener">https://github.com/snowdream</a></li><li>Blog: <a href="http://snowdream.github.io/blog/" target="_blank" rel="noopener">http://snowdream.github.io/blog/</a></li><li>简书：<a href="http://www.jianshu.com/u/748f0f7e6432" target="_blank" rel="noopener">http://www.jianshu.com/u/748f0f7e6432</a></li><li>云栖博客：<a href="https://yq.aliyun.com/u/snowdream86" target="_blank" rel="noopener">https://yq.aliyun.com/u/snowdream86</a> </li><li>QQ群: 529327615     </li><li>微信公众号:  sn0wdr1am    </li></ul><p><img src="https://static.dingtalk.com/media/lADOmAwFCs0BAs0BAg_258_258.jpg" alt="sn0wdr1am"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在Gradle中运行单元测试很简单。一般情况下，如果有一个单元测试CASE执行失败，也会导致构建失败。但是我们却不能立刻在控制台看到为什么这个单元测试失败。我们需要先打开生成的HTML格式的测试报告。现在我们还有其他办法。&lt;/p&gt;
&lt;p&gt;首先，我们创建一个下面的Gradle
      
    
    </summary>
    
      <category term="gradle" scheme="http://www.snowdream.tech/categories/gradle/"/>
    
    
      <category term="gradle" scheme="http://www.snowdream.tech/tags/gradle/"/>
    
  </entry>
  
  <entry>
    <title>Android开发中遇到的的Gradle相关问题总结</title>
    <link href="http://www.snowdream.tech/2016/11/27/gradle-issues-with-android/"/>
    <id>http://www.snowdream.tech/2016/11/27/gradle-issues-with-android/</id>
    <published>2016-11-27T07:06:08.000Z</published>
    <updated>2018-04-19T02:49:42.027Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>作者：snowdream<br>Email：yanghui1986527#gmail.com<br>Github: <a href="https://github.com/snowdream" target="_blank" rel="noopener">https://github.com/snowdream</a><br>QQ 群: 529327615<br>原文地址：<a href="https://snowdream.github.io/blog/2016/11/27/gradle-issues-with-android/" target="_blank" rel="noopener">https://snowdream.github.io/blog/2016/11/27/gradle-issues-with-android/</a></p></blockquote><p>现在，大家都慢慢开始习惯使用Android Studio来开发Android应用了。<br>在使用过程中，难免碰到一些Gralde相关的使用问题。下面总结我收集整理的一些碰到的问题，以及解决方案：</p><h2 id="1-问题：-Maven源仓库不可用，或者访问，下载非常慢。"><a href="#1-问题：-Maven源仓库不可用，或者访问，下载非常慢。" class="headerlink" title="1. 问题： Maven源仓库不可用，或者访问，下载非常慢。"></a>1. 问题： Maven源仓库不可用，或者访问，下载非常慢。</h2><p><strong>分析</strong>： 由于主要的仓库Maven，Jcenter都在国外，以及众所周知的原因，这些Maven仓库可能比较慢。而我们从新建／导入工程开始，就要和Maven源仓库进行交互，因此，这可能导致我们导入或者打开工程非常的缓慢。</p><p><strong>解决方案</strong>：</p><ol><li><p>优先使用国内Maven仓库镜像。推荐：阿里云Maven仓库镜像</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">maven &#123; url “http://maven.aliyun.com/mvn/repository/“ &#125;</span><br></pre></td></tr></table></figure></li><li><p>使用http协议访问Maven仓库。使用下面的仓库来替换默认的 jcenter() 和 mavenCentral()</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">jcenter &#123; url “http://jcenter.bintray.com/&quot;&#125;</span><br><span class="line">maven &#123; url “http://repo1.maven.org/maven2&quot;&#125;</span><br></pre></td></tr></table></figure></li><li><p>如果你的项目不需要频繁从Maven仓库更新／下载组件，那么强烈建议你打开offline模式。</p></li></ol><h2 id="2-问题：-Android-Studio导入工程非常慢，甚至卡死在导入阶段。"><a href="#2-问题：-Android-Studio导入工程非常慢，甚至卡死在导入阶段。" class="headerlink" title="2. 问题： Android Studio导入工程非常慢，甚至卡死在导入阶段。"></a>2. 问题： Android Studio导入工程非常慢，甚至卡死在导入阶段。</h2><p><strong>分析</strong>：Android Studio导入工程，默认会采用Gradle Wrapper的方式。也就是当你在本地没有下载过相应版本的Gradle，在导入工程前，就会去尝试下载相应版本的Gradle。</p><p>关于Gradle Wrapper的配置文件，在项目根目录下gradle/wrapper下。通常是两个文件：gradle-wrapper.jar和gradle-wrapper.properties</p><p>我们来看看gradle-wrapper.properties文件：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">#Mon Dec 28 10:00:20 PST 2015</span><br><span class="line">distributionBase=GRADLE_USER_HOME</span><br><span class="line">distributionPath=wrapper/dists</span><br><span class="line">zipStoreBase=GRADLE_USER_HOME</span><br><span class="line">zipStorePath=wrapper/dists</span><br><span class="line">distributionUrl=https\://services.gradle.org/distributions/gradle-2.14.1-all.zip</span><br></pre></td></tr></table></figure></p><p>没错，如果你之前没有通过Gradle Wrapper方式下载过这个版本Gradle，那么你导入工程后，第一件事情就是通过distributionUrl去下载gradle。然而，我们从这个来自Gradle官方的下载地址下载是非常慢的。</p><p><strong>解决方案</strong>：<br>1.搭建局域网HTTP服务器，镜像Gradle主流版本安装包。<br>参考：腾讯的方案：<a href="http://android-mirror.bugly.qq.com:8080/gradle/" target="_blank" rel="noopener">http://android-mirror.bugly.qq.com:8080/gradle/</a></p><p>2.在项目根目录build.gradle配置一个gradle wrapper任务。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">task wrapper(type: Wrapper) &#123;</span><br><span class="line">    gradleVersion = &apos;3.1&apos;</span><br><span class="line">    distributionUrl = &quot;http://android-mirror.bugly.qq.com:8080/gradle/gradle-$&#123;gradleVersion&#125;-bin.zip&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>其中：gradleVersion对应gradle版本号，而distributionUrl则是对应版本的Gradle安装包下载地址。</p><p>3.在根目录下执行gradle wrapper 命令，然后将根目录下的gradle目录提交至git仓库。</p><h2 id="3-问题：-导入工程后，在Gradle-Sync阶段卡死。"><a href="#3-问题：-导入工程后，在Gradle-Sync阶段卡死。" class="headerlink" title="3. 问题： 导入工程后，在Gradle Sync阶段卡死。"></a>3. 问题： 导入工程后，在Gradle Sync阶段卡死。</h2><p>具体表现为：你以前已经在Android Studio中打开该工程，但是当你升级了本地Gradle版本，又或者使用Intellij IDEA打开，你会发现导入很慢。即使进去主界面，Gradle Sync也会处于假死状态，好像一直在加载什么。。。</p><p><strong>分析</strong>： 不明</p><p><strong>解决方案</strong>：根据网上的建议，排除以上原因之后，你可以这么干：删除工程下的.gradle文件夹，然后重新导入工程。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;作者：snowdream&lt;br&gt;Email：yanghui1986527#gmail.com&lt;br&gt;Github: &lt;a href=&quot;https://github.com/snowdream&quot; target=&quot;_blank&quot; rel=&quot;noopen
      
    
    </summary>
    
      <category term="gradle" scheme="http://www.snowdream.tech/categories/gradle/"/>
    
    
      <category term="android" scheme="http://www.snowdream.tech/tags/android/"/>
    
      <category term="gradle" scheme="http://www.snowdream.tech/tags/gradle/"/>
    
  </entry>
  
  <entry>
    <title>Android WiFi ADB</title>
    <link href="http://www.snowdream.tech/2016/10/27/wifi-adb-without-usb/"/>
    <id>http://www.snowdream.tech/2016/10/27/wifi-adb-without-usb/</id>
    <published>2016-10-27T03:50:16.000Z</published>
    <updated>2018-04-19T02:49:42.027Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>作者：snowdream<br>Email：yanghui1986527#gmail.com<br>Github: <a href="https://github.com/snowdream" target="_blank" rel="noopener">https://github.com/snowdream</a><br>QQ 群: 529327615<br>原文地址：<a href="https://snowdream.github.io/blog/2016/10/27/wifi-adb-without-usb/" target="_blank" rel="noopener">https://snowdream.github.io/blog/2016/10/27/wifi-adb-without-usb/</a></p></blockquote><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>大家在开发调试Android应用的时候，都需要使用USB连接电脑和测试手机。<br>那么如何通过WIFI来连接电脑和测试手机呢？  </p><p>通常的做法是这样：<br>安装idea插件<a href="https://github.com/pedrovgs/AndroidWiFiADB" target="_blank" rel="noopener">AndroidWiFiADB</a>。通过这个插件，只需要用USB连接一次电脑和测试手机，之后就可以只通过WIFI来连接了。   </p><p>那么有没有方法，完全通过WIFI来进行连接呢？<br>下面就要介绍这样一款工具：<a href="https://github.com/Sausure/WIFIADB" target="_blank" rel="noopener">WIFIADB</a></p><h2 id="前提"><a href="#前提" class="headerlink" title="前提"></a>前提</h2><p>Android手机需要Root</p><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><h3 id="WIFIADBIntelliJPlugin"><a href="#WIFIADBIntelliJPlugin" class="headerlink" title="WIFIADBIntelliJPlugin"></a>WIFIADBIntelliJPlugin</h3><p>在Idea/Android studio插件安装对话框输入“WIFI ADB ULTIMATE”，安装插件，然后重启IDE。<br><img src="https://raw.githubusercontent.com/Sausure/WIFIADB/master/WIFIADBIntelliJPlugin/art/search.png" alt="WIFIADBIntelliJPlugin"></p><h3 id="WIFIADBAndroid"><a href="#WIFIADBAndroid" class="headerlink" title="WIFIADBAndroid"></a>WIFIADBAndroid</h3><ol><li>点击，下载安装<a href="https://github.com/Sausure/WIFIADB/raw/master/WIFIADBAndroid/app/out/WIFIADBANDROID-RELEASE-1.0.APK" target="_blank" rel="noopener">WIFIADBANDROID-RELEASE-1.0.APK</a></li><li>测试手机连接wifi</li><li>启动应用，点击主界面中间的圆形按钮。如果启动成功，底部会提示IP地址和端口号。<br><img src="https://raw.githubusercontent.com/Sausure/WIFIADB/master/WIFIADBAndroid/art/demo.gif" alt="WIFIADBAndroid"></li></ol><h2 id="运行"><a href="#运行" class="headerlink" title="运行"></a>运行</h2><p>在Idea/Android studio界面右侧，点击标签““WIFI ADB ULTIMATE””，输入IP地址和端口号,点击“Connect”即可。</p><p><img src="https://raw.githubusercontent.com/Sausure/WIFIADB/master/WIFIADBIntelliJPlugin/art/screenshot1.png" alt="WIFI ADB ULTIMATE"><img src="https://raw.githubusercontent.com/Sausure/WIFIADB/master/WIFIADBIntelliJPlugin/art/screenshot2.png" alt="WIFI ADB ULTIMATE"></p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol><li><a href="https://github.com/Sausure/WIFIADB" target="_blank" rel="noopener">WIFIADB</a></li><li><a href="https://github.com/pedrovgs/AndroidWiFiADB" target="_blank" rel="noopener">AndroidWiFiADB</a></li><li><a href="https://github.com/layerlre/ADBWIFI" target="_blank" rel="noopener">ADBWIFI</a></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;作者：snowdream&lt;br&gt;Email：yanghui1986527#gmail.com&lt;br&gt;Github: &lt;a href=&quot;https://github.com/snowdream&quot; target=&quot;_blank&quot; rel=&quot;noopen
      
    
    </summary>
    
      <category term="tools" scheme="http://www.snowdream.tech/categories/tools/"/>
    
    
      <category term="tools" scheme="http://www.snowdream.tech/tags/tools/"/>
    
  </entry>
  
  <entry>
    <title>Gradle精选: 通过模拟运行检查Task依赖</title>
    <link href="http://www.snowdream.tech/2016/10/26/gradle-goodness-check-task-dependencies/"/>
    <id>http://www.snowdream.tech/2016/10/26/gradle-goodness-check-task-dependencies/</id>
    <published>2016-10-26T10:20:56.000Z</published>
    <updated>2018-04-19T02:49:42.027Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>作者：snowdream<br>Email：yanghui1986527#gmail.com<br>Github: <a href="https://github.com/snowdream" target="_blank" rel="noopener">https://github.com/snowdream</a><br>QQ 群: 529327615<br>原文地址：<a href="https://snowdream.github.io/blog/2016/10/26/gradle-goodness-check-task-dependencies/" target="_blank" rel="noopener">https://snowdream.github.io/blog/2016/10/26/gradle-goodness-check-task-dependencies/</a></p></blockquote><p>翻译自： <a href="http://mrhaki.blogspot.com/2014/11/gradle-goodness-check-task-dependencies.html" target="_blank" rel="noopener">http://mrhaki.blogspot.com/2014/11/gradle-goodness-check-task-dependencies.html</a></p><p>我们可以运行Gradle的任务，但是不实际执行动作。这就是所谓的模拟运行。我们可以通过模拟运行来查看，我们定义的任务依赖关系是否正确。因为，我们在进行模拟运行时，我们可以看到所有的任务和任务依赖关系输出日志。</p><p>例如，我们定义了一个简单的build文件，包含三个任务和一些任务依赖关系:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">def printTaskNameAction = &#123;</span><br><span class="line">    println &quot;Running $&#123;it.name&#125;&quot;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">task first &lt;&lt; printTaskNameAction</span><br><span class="line"> </span><br><span class="line">task second(dependsOn: first) &lt;&lt; printTaskNameAction</span><br><span class="line"> </span><br><span class="line">task third(dependsOn: [first, second]) &lt;&lt; printTaskNameAction</span><br></pre></td></tr></table></figure></p><p>我们通过添加命令行选项 -m or –dry-run来进行模拟运行。因此，我们这样执行第三个任务：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ gradle -m third</span><br><span class="line">:first SKIPPED</span><br><span class="line">:second SKIPPED</span><br><span class="line">:third SKIPPED</span><br><span class="line"> </span><br><span class="line">BUILD SUCCESSFUL</span><br><span class="line"> </span><br><span class="line">Total time: 2.242 secs</span><br><span class="line">$</span><br></pre></td></tr></table></figure></p><p>我们在输出中可以看到，没有任何任务是实际被执行的，在输出日志中显示SKIPPED，但是我们可以看到所有被执行任务的名字。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;作者：snowdream&lt;br&gt;Email：yanghui1986527#gmail.com&lt;br&gt;Github: &lt;a href=&quot;https://github.com/snowdream&quot; target=&quot;_blank&quot; rel=&quot;noopen
      
    
    </summary>
    
      <category term="gradle" scheme="http://www.snowdream.tech/categories/gradle/"/>
    
    
      <category term="gradle" scheme="http://www.snowdream.tech/tags/gradle/"/>
    
  </entry>
  
  <entry>
    <title>Gradle精选: 修改默认的Build配置文件名</title>
    <link href="http://www.snowdream.tech/2016/10/26/gradle-goodness-changing-name-of/"/>
    <id>http://www.snowdream.tech/2016/10/26/gradle-goodness-changing-name-of/</id>
    <published>2016-10-26T08:14:14.000Z</published>
    <updated>2018-04-19T02:49:42.027Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>作者：snowdream<br>Email：yanghui1986527#gmail.com<br>Github: <a href="https://github.com/snowdream" target="_blank" rel="noopener">https://github.com/snowdream</a><br>QQ 群: 529327615<br>原文地址：<a href="https://snowdream.github.io/blog/2016/10/26/gradle-goodness-changing-name-of/" target="_blank" rel="noopener">https://snowdream.github.io/blog/2016/10/26/gradle-goodness-changing-name-of/</a></p></blockquote><p>翻译自： <a href="http://mrhaki.blogspot.com/2014/10/gradle-goodness-changing-name-of.html" target="_blank" rel="noopener">http://mrhaki.blogspot.com/2014/10/gradle-goodness-changing-name-of.html</a></p><p>Gradle默认使用<strong>build.gradle</strong>作为默认的配置文件文件名。如果我们在<strong>build.gradle</strong>文件中编写代码，那么我们在运行任务的时候，不需要指定build文件名。我们也可以不使用<strong>build.gradle</strong>，而用另外的文件名来创建build配置文件。例如：我们可以在一个名字为<strong>sample.gradle</strong>的文件中编写代码。为了运行这个文件中的任务，我们需要在命令行，使用选项 -b 或者 –build-file，后面指定build文件名。但是，我们可以改变项目设置，并且设置项目的默认build文件名。这样设置，我们不需要再使用前面的命令行选项。</p><p>假设我们现在有一个build文件，<strong>sample.gradle</strong>:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// File: sample.gradle</span><br><span class="line">task sample(description: &apos;Sample task&apos;) &lt;&lt; &#123;</span><br><span class="line">    println &apos;Sample task&apos;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">defaultTasks &apos;sample&apos;</span><br></pre></td></tr></table></figure></p><p>为了运行sample任务，我们可以使用命令行选项 -b 或者 –build-file：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">$ gradle -b sample.gradle</span><br><span class="line">:sample</span><br><span class="line">Sample task</span><br><span class="line"> </span><br><span class="line">BUILD SUCCESSFUL</span><br><span class="line"> </span><br><span class="line">Total time: 3.168 secs</span><br><span class="line">$ gradle --build-file sample.gradle</span><br><span class="line">:sample</span><br><span class="line">Sample task</span><br><span class="line"> </span><br><span class="line">BUILD SUCCESSFUL</span><br><span class="line"> </span><br><span class="line">Total time: 2.148 secs</span><br><span class="line">$</span><br></pre></td></tr></table></figure></p><p>我们也可以改变项目默认的build文件名。首先，我们在项目根目录下创建项目设置文件<strong>settings.gradle</strong>。 在<strong>settings.gradle</strong>文件中，我们给<strong>rootProject</strong>修改属性值<strong>buildFileName</strong>：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">// File: settings.gradle</span><br><span class="line">// Change default build file name for this project.</span><br><span class="line">rootProject.buildFileName = &apos;sample.gradle&apos;</span><br></pre></td></tr></table></figure></p><p>现在，我们执行<strong>sample.gradle</strong>中的任务，不再需要使用命令行选项-b 或者 –build-file了。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ gradle</span><br><span class="line">:sample</span><br><span class="line">Sample task</span><br><span class="line"> </span><br><span class="line">BUILD SUCCESSFUL</span><br><span class="line"> </span><br><span class="line">Total time: 3.312 secs</span><br><span class="line">$</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;作者：snowdream&lt;br&gt;Email：yanghui1986527#gmail.com&lt;br&gt;Github: &lt;a href=&quot;https://github.com/snowdream&quot; target=&quot;_blank&quot; rel=&quot;noopen
      
    
    </summary>
    
      <category term="gradle" scheme="http://www.snowdream.tech/categories/gradle/"/>
    
    
      <category term="gradle" scheme="http://www.snowdream.tech/tags/gradle/"/>
    
  </entry>
  
  <entry>
    <title>Android优化系列一： 日志清理</title>
    <link href="http://www.snowdream.tech/2016/10/22/android-optimalize-series-log/"/>
    <id>http://www.snowdream.tech/2016/10/22/android-optimalize-series-log/</id>
    <published>2016-10-22T14:19:41.000Z</published>
    <updated>2018-04-19T02:49:42.023Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>作者：snowdream<br>Email：yanghui1986527#gmail.com<br>Github: <a href="https://github.com/snowdream" target="_blank" rel="noopener">https://github.com/snowdream</a><br>QQ 群: 529327615<br>原文地址：<a href="https://snowdream.github.io/blog/2016/10/22/android-optimalize-series-log/" target="_blank" rel="noopener">https://snowdream.github.io/blog/2016/10/22/android-optimalize-series-log/</a></p></blockquote><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>在Android应用开发过程中，通过Log类输出日志是一种很重要的调试手段。<br>大家对于Log类的使用，一般会形成几点共识：</p><ol><li>在Debug模式下打印日志，在Release模式下不打印日志</li><li>避免滥用Log类进行输出日志。因为这样可能造成日志刷屏，淹没真正有用的日志。</li><li>封装Log类，以提供同时输出日志到文件等功能</li></ol><p>具体细化为以下几点建议：</p><ol><li>禁用System.out.println<br>Android应用中，一般通过封装过的Log类来输出日志，方便控制。而System.out.println是标准的Java输出方法，使用不当，可能造成Release模式下输出日志的结果。</li><li><p>禁用e.printStackTrace<br>禁用理由同上<br>建议通过封装过的Log类来输出异常堆栈信息</p></li><li><p>Debug模式下，通过一个静态变量，控制日志的显示隐藏。<br>我一般习惯直接使用BuildConfig.DEBUG，当然，你也可以自己定义一个。 </p></li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">private static final boolean isDebug = BuildConfig.DEBUG;</span><br><span class="line"></span><br><span class="line">public static void i(String tag, String msg) &#123;</span><br><span class="line">    if (isDebug) &#123;</span><br><span class="line">        Log.i(tag, msg);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>4.Release模式下，通过Proguard配置来移除日志<br>在Proguard配置文件中，确保没有添加 –dontoptimize选项 来禁用优化的前提下，<br>添加以下代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">-assumenosideeffects class android.util.Log &#123;</span><br><span class="line">        public static *** d(...);</span><br><span class="line">        public static *** e(...);</span><br><span class="line">        public static *** i(...);</span><br><span class="line">        public static *** v(...);</span><br><span class="line">        public static *** println(...);</span><br><span class="line">        public static *** w(...);</span><br><span class="line">        public static *** wtf(...);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>那么，是否我们按照上面的做，就真的一劳永逸呢？<br>我的脑海中浮现出几个相关问题：</p><ol><li>Proguard配置中添加的配置，真的可以在Release模式下，移除日志吗？</li><li>如果我们用的是封装过的Log工具类，应该怎么配置？</li><li>移除日志后，原来在日志方法中的拼接字符串参数，是否还会申请/占用内存？<br>…</li></ol><p>本着大胆假设，小心求证的原则，下面我们通过实践来探索上面的问题答案。</p><p>本文基于以下项目进行测试实践：<br><a href="https://github.com/snowdream/test/tree/master/android/test/logtest" target="_blank" rel="noopener">https://github.com/snowdream/test/tree/master/android/test/logtest</a><br>反编译工具：<a href="http://jd.benow.ca/" target="_blank" rel="noopener">JD-GUI</a></p><h2 id="验证Proguard配置清理日志的有效性"><a href="#验证Proguard配置清理日志的有效性" class="headerlink" title="验证Proguard配置清理日志的有效性"></a>验证Proguard配置清理日志的有效性</h2><h3 id="CASE"><a href="#CASE" class="headerlink" title="CASE"></a>CASE</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Log.i(TAG,&quot;这样使用，得到的LOGTAG的值就是DroidSettings，&quot; +</span><br><span class="line">        &quot;然而并非如此，当DroidSettings这个类进行了混淆之后，类名变成了类似a,b,c这样的名称，&quot; +</span><br><span class="line">        &quot;LOGTAG则不再是DroidSettings这个值了。这样可能造成的问题就是，内部混淆有日志的包，我们去过滤DroidSettings &quot; +</span><br><span class="line">        &quot;却永远得不到任何信息。&quot;);</span><br></pre></td></tr></table></figure><p>在添加上述Proguard配置前后，编译打包Release模式的正式包，使用JD-GUI进行反编译，对比上述代码的编译后代码。</p><h3 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h3><p>添加配置前<br><img src="/2016/10/22/android-optimalize-series-log/case1-a.png" title="[case1-a]"></p><p>添加配置后<br><img src="/2016/10/22/android-optimalize-series-log/case1-b.png" title="[case1-b]"></p><h3 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h3><p>通过比对结果，我们可以得出结论：<br>通过添加Proguard配置，可以在Release模式下，移除掉日志。</p><h2 id="验证封装过的Log工具类，是否有必要进行而外配置"><a href="#验证封装过的Log工具类，是否有必要进行而外配置" class="headerlink" title="验证封装过的Log工具类，是否有必要进行而外配置"></a>验证封装过的Log工具类，是否有必要进行而外配置</h2><h3 id="CASE-1"><a href="#CASE-1" class="headerlink" title="CASE"></a>CASE</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">LogUtil.i(TAG,&quot;这样使用，得到的LOGTAG的值就是DroidSettings，&quot; +</span><br><span class="line">        &quot;然而并非如此，当DroidSettings这个类进行了混淆之后，类名变成了类似a,b,c这样的名称，&quot; +</span><br><span class="line">        &quot;LOGTAG则不再是DroidSettings这个值了。这样可能造成的问题就是，内部混淆有日志的包，我们去过滤DroidSettings &quot; +</span><br><span class="line">        &quot;却永远得不到任何信息。&quot;);</span><br></pre></td></tr></table></figure><p>在添加上述Proguard配置前后，编译打包Release模式的正式包，使用JD-GUI进行反编译，对比上述代码的编译后代码。</p><h3 id="结果-1"><a href="#结果-1" class="headerlink" title="结果"></a>结果</h3><p>添加配置前<br><img src="/2016/10/22/android-optimalize-series-log/case2-a.png" title="[case2-a]"></p><p>添加配置后<br><img src="/2016/10/22/android-optimalize-series-log/case2-b.png" title="[case2-b]"></p><h3 id="结论-1"><a href="#结论-1" class="headerlink" title="结论"></a>结论</h3><p>通过比对结果，我们可以得出结论：<br>在这种简单封装的情况下，我们不需要额外的配置，也可以将封装过的Log工具类调用日志一起移除。</p><p>当然，实际使用过程中，可能封装更复杂。为了保险起见，可以也添加上Log工具类的配置。示例如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">-assumenosideeffects class com.github.snowdream.logtest.LogUtil &#123;</span><br><span class="line">        public static *** d(...);</span><br><span class="line">        public static *** e(...);</span><br><span class="line">        public static *** i(...);</span><br><span class="line">        public static *** v(...);</span><br><span class="line">        public static *** w(...);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="验证移除日志后，字符串拼接是否还存在？"><a href="#验证移除日志后，字符串拼接是否还存在？" class="headerlink" title="验证移除日志后，字符串拼接是否还存在？"></a>验证移除日志后，字符串拼接是否还存在？</h2><h3 id="CASE-2"><a href="#CASE-2" class="headerlink" title="CASE"></a>CASE</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Log.i(TAG,&quot;这样使用，得到的LOGTAG的值就是DroidSettings，&quot; +</span><br><span class="line">        &quot;然而并非如此，当DroidSettings这个类进行了混淆之后，类名变成了类似a,b,c这样的名称，&quot; +</span><br><span class="line">        &quot;LOGTAG则不再是DroidSettings这个值了。这样可能造成的问题就是，内部混淆有日志的包，我们去过滤DroidSettings &quot; +</span><br><span class="line">        &quot;却永远得不到任何信息。&quot;);</span><br><span class="line"></span><br><span class="line">Log.i(TAG, &quot;这样使用，得到的LOGTAG的值就是DroidSettings，&quot; +</span><br><span class="line">        &quot;然而并非如此，当DroidSettings这个类进行了混淆之后，类名变成了类似a,b,c这样的名称，&quot; +</span><br><span class="line">        &quot;LOGTAG则不再是DroidSettings这个值了。这样可能造成的问题就是，内部混淆有日志的包，我们去过滤DroidSettings &quot; +</span><br><span class="line">        &quot;却永远得不到任何信息。&quot; + index ++);</span><br></pre></td></tr></table></figure><p>上面代码的区别是：<br>前面是简单的字符串相加，而后面是字符串和变量的相加<br>在添加上述Proguard配置的前提下，分别针对以上两段代码，编译打包Release模式的正式包，使用JD-GUI进行反编译，对比上述代码的编译后代码。</p><h3 id="结果-2"><a href="#结果-2" class="headerlink" title="结果"></a>结果</h3><p>简单字符串相加<br><img src="/2016/10/22/android-optimalize-series-log/case1-b.png" title="[case1-b]"></p><p>字符串和变量相加<br><img src="/2016/10/22/android-optimalize-series-log/case3.png" title="[case3.png]"></p><h3 id="结论-2"><a href="#结论-2" class="headerlink" title="结论"></a>结论</h3><p>通过比对结果，我们可以得出结论：<br>如果只是简单字符串相加，是会彻底移除的，并且字符串拼接也不见了，不会占用内存。<br>而如果是字符串和变量相加，日志会移除，但是字符串拼接还在，还会占用内存。</p><h2 id="验证日志中使用函返回值的情况"><a href="#验证日志中使用函返回值的情况" class="headerlink" title="验证日志中使用函返回值的情况"></a>验证日志中使用函返回值的情况</h2><h3 id="CASE-3"><a href="#CASE-3" class="headerlink" title="CASE"></a>CASE</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">LogUtil.i(TAG, getMessage());</span><br><span class="line"></span><br><span class="line">LogUtil.i(TAG, &quot;FROM FUNCTION &quot; + getMessage());</span><br><span class="line"></span><br><span class="line">private String getMessage() &#123;</span><br><span class="line">    return  &quot;这样使用，得到的LOGTAG的值就是DroidSettings，&quot; +</span><br><span class="line">        &quot;然而并非如此，当DroidSettings这个类进行了混淆之后，类名变成了类似a,b,c这样的名称，&quot; +</span><br><span class="line">        &quot;LOGTAG则不再是DroidSettings这个值了。这样可能造成的问题就是，内部混淆有日志的包，我们去过滤DroidSettings &quot; +</span><br><span class="line">        &quot;却永远得不到任何信息。&quot;；</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码的区别是：<br>前面是直接使用函数返回值，而后面是字符串和函数返回值的相加<br>在添加上述Proguard配置的前提下，分别针对以上两段代码，编译打包Release模式的正式包，使用JD-GUI进行反编译，对比上述代码的编译后代码。</p><h3 id="结果-3"><a href="#结果-3" class="headerlink" title="结果"></a>结果</h3><p>直接使用函数返回值<br><img src="/2016/10/22/android-optimalize-series-log/case1-b.png" title="[case1-b]"></p><p>字符串和函数返回值相加<br><img src="/2016/10/22/android-optimalize-series-log/case4.png" title="[case4.png]"></p><h3 id="结论-3"><a href="#结论-3" class="headerlink" title="结论"></a>结论</h3><p>通过比对结果，我们可以得出结论：<br>以上两种场景下，日志移除，拼接字符串不在了，也不会占用内存。</p><h2 id="经过大量实践后的结论"><a href="#经过大量实践后的结论" class="headerlink" title="经过大量实践后的结论"></a>经过大量实践后的结论</h2><p>如果你以为上面就是全部真相的话，就错了。<br>经过大量的测试实践，实际上真相更复杂。</p><p>以下是开启Proguard前提下，各种情况下的测试结论：</p><ol><li>Log.i（简单字符串）</li><li>Log.i（局部变量）</li><li>Log.i（成员变量）</li><li>Log.i（简单字符串+局部变量）<br>以上四种情况，日志被彻底移除，不会额外增加内存。</li><li>Log.i（简单字符串+成员变量）<br>日志被移除，但是字符串拼接会存在，并占用内存。</li><li>Log.i（成员函数） 其中，成员函数返回值为： 简单字符串</li><li>Log.i（成员函数） 其中，成员函数返回值为： 简单字符串+局部变量<br>以上两种情况，日志被彻底移除，不会额外增加内存。</li><li>Log.i（成员函数） 其中，成员函数返回值为： 简单字符串+成员变量<br>日志被移除，但是字符串拼接会存在，并占用内存。  </li></ol><p>注：以上所有情况,参数都是指第二个或者后面的参数。第一个参数，我都使用了静态成员变量：<br>private static final String TAG = MainActivity.class.getSimpleName();</p><h3 id="优化建议"><a href="#优化建议" class="headerlink" title="优化建议"></a>优化建议</h3><ol><li><p>确保没有开启 –dontoptimize选项的前提下，添加Proguard优化日志配置</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">-assumenosideeffects class android.util.Log &#123;</span><br><span class="line">        public static *** d(...);</span><br><span class="line">        public static *** e(...);</span><br><span class="line">        public static *** i(...);</span><br><span class="line">        public static *** v(...);</span><br><span class="line">        public static *** println(...);</span><br><span class="line">        public static *** w(...);</span><br><span class="line">        public static *** wtf(...);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>针对这种情况“Log.i（成员函数） 其中，成员函数返回值为： 简单字符串+成员变量”<br>目前并没有办法规避，不建议这么使用。</p></li><li>针对这种情况”Log.i（简单字符串+成员变量)”<br>我们的解决方案是，在封装的Log工具类方法中，使用变长参数。<br>下面是一个简单的示例：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">package com.github.snowdream.logtest;</span><br><span class="line"></span><br><span class="line">import android.text.TextUtils;</span><br><span class="line">import android.util.Log;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * Created by snowdream on 16-10-22.</span><br><span class="line"> */</span><br><span class="line">public class LogUtil &#123;</span><br><span class="line">    private static final boolean isDebug = BuildConfig.DEBUG;</span><br><span class="line"></span><br><span class="line">    public static void i(String tag, String... args) &#123;</span><br><span class="line">        if (isDebug) &#123;</span><br><span class="line">            Log.i(tag, getLog(tag,args));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void d(String tag, String... args) &#123;</span><br><span class="line">        if (isDebug) &#123;</span><br><span class="line">            Log.i(tag, getLog(tag,args));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void v(String tag, String... args) &#123;</span><br><span class="line">        if (isDebug) &#123;</span><br><span class="line">            Log.i(tag, getLog(tag,args));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void w(String tag, String... args) &#123;</span><br><span class="line">        if (isDebug) &#123;</span><br><span class="line">            Log.i(tag, getLog(tag,args));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void e(String tag, String... args) &#123;</span><br><span class="line">        if (isDebug) &#123;</span><br><span class="line">            Log.i(tag, getLog(tag,args));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private static String getLog(String tag, String... args)&#123;</span><br><span class="line">        StringBuilder builder = new StringBuilder();</span><br><span class="line">        for (String arg : args)&#123;</span><br><span class="line">            if (TextUtils.isEmpty(arg)) continue;</span><br><span class="line"></span><br><span class="line">            builder.append(arg);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return builder.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol><li><a href="http://weishu.me/2015/10/19/how-to-log-safely-in-android/" target="_blank" rel="noopener">如何安全地打印日志</a></li><li><a href="http://droidyue.com/blog/2015/11/01/thinking-about-android-log/" target="_blank" rel="noopener">关于Android Log的一些思考</a></li><li><a href="http://www.jianshu.com/p/4b61391a665f" target="_blank" rel="noopener">Androrid应用打包release版时关闭log日志输出</a></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;作者：snowdream&lt;br&gt;Email：yanghui1986527#gmail.com&lt;br&gt;Github: &lt;a href=&quot;https://github.com/snowdream&quot; target=&quot;_blank&quot; rel=&quot;noopen
      
    
    </summary>
    
      <category term="android" scheme="http://www.snowdream.tech/categories/android/"/>
    
    
      <category term="android" scheme="http://www.snowdream.tech/tags/android/"/>
    
  </entry>
  
  <entry>
    <title>移动应用开发流程探索</title>
    <link href="http://www.snowdream.tech/2016/10/20/mobile-app-develop-flow/"/>
    <id>http://www.snowdream.tech/2016/10/20/mobile-app-develop-flow/</id>
    <published>2016-10-20T10:09:40.000Z</published>
    <updated>2018-04-19T02:49:42.027Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>作者：snowdream<br>Email：yanghui1986527#gmail.com<br>Github: <a href="https://github.com/snowdream" target="_blank" rel="noopener">https://github.com/snowdream</a><br>QQ 群: 529327615<br>原文地址：<a href="https://snowdream.github.io/blog/2016/10/20/mobile-app-develop-flow/" target="_blank" rel="noopener">https://snowdream.github.io/blog/2016/10/20/mobile-app-develop-flow/</a></p></blockquote><p>众所周知，移动应用一般都是按照预定周期进行迭代的，比如：一月发三版，两周发一版。</p><p>每一个迭代周期内，都会有产品，UI，研发，测试的逐步介入。</p><p>各种角色之间可能会有不同的依赖关系，他们并不能完全并行的工作。</p><p>本文主要从研发环节，以一个Android RD的视角，探索移动应用的开发流程。</p><h2 id="名词解释"><a href="#名词解释" class="headerlink" title="名词解释"></a>名词解释</h2><h3 id="API"><a href="#API" class="headerlink" title="API"></a>API</h3><p>本文主要泛指服务端</p><h3 id="SDK"><a href="#SDK" class="headerlink" title="SDK"></a>SDK</h3><p>本文主要泛指本地模块端。在模块化的背景下，移动应用被分隔成不同的模块。这些模块有可能是独立的，也有可能依赖于服务端（API）。</p><h3 id="Client"><a href="#Client" class="headerlink" title="Client"></a>Client</h3><p>本文主要泛指客户端</p><h2 id="开发流程"><a href="#开发流程" class="headerlink" title="开发流程"></a>开发流程</h2><h3 id="串行开发"><a href="#串行开发" class="headerlink" title="串行开发"></a>串行开发</h3><img src="/2016/10/20/mobile-app-develop-flow/chuanxing.svg" title="[串行开发流程图]"><p>串行开发比较好理解，就是每个环节依次进行，每个环节都给出完整，可用的输出，提供给下一个环节，直至最后给测试。</p><h4 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h4><p>每个环节给出的输出都是经过充分测试，可用的成果。</p><h4 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h4><p>每个环节要等上一个环节完成开发，之后，再进行开发。</p><p>结果往往是，下游环节的同学，在迭代初期，开发进程被阻塞，迭代后期，因为工期紧，而没日没夜的加班。</p><p>浪费时间和人力。</p><h3 id="并行开发"><a href="#并行开发" class="headerlink" title="并行开发"></a>并行开发</h3><img src="/2016/10/20/mobile-app-develop-flow/bingxing.svg" title="[并行开发流程图]"><p>并行开发就是API，SDK，Client各类开发人员约定接口/协议，同时进行开发。</p><p>至少分为两个阶段： </p><p>第一阶段：<br>上游环节和下游环节约定好接口/协议，并提供有接口但是无实现的依赖成果，输出给下游环节。</p><p>下游环节根据这些进行并行开发。</p><p>第二阶段：<br>上游环节完成接口/协议的实现，经过充分测试，输出完整的成果。</p><p>等待下游环节完成开发时，进行一次连接调试，确保业务流程完整，功能正常。</p><h4 id="优点-1"><a href="#优点-1" class="headerlink" title="优点"></a>优点</h4><p>各个环节约定好接口/协议之后，可以并行开发。</p><h4 id="要求"><a href="#要求" class="headerlink" title="要求"></a>要求</h4><p>这个需要各个环节的人员，进行及时，有效的沟通。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>根据之前的项目实践，我比较偏向于并行开发。</p><p>当然，对于移动应用开发流程的理解，大家见仁见智，欢迎讨论。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;作者：snowdream&lt;br&gt;Email：yanghui1986527#gmail.com&lt;br&gt;Github: &lt;a href=&quot;https://github.com/snowdream&quot; target=&quot;_blank&quot; rel=&quot;noopen
      
    
    </summary>
    
      <category term="project" scheme="http://www.snowdream.tech/categories/project/"/>
    
    
      <category term="project" scheme="http://www.snowdream.tech/tags/project/"/>
    
  </entry>
  
  <entry>
    <title>Genymotion安装配置指南</title>
    <link href="http://www.snowdream.tech/2016/10/17/android-genymotion-install-and-settings/"/>
    <id>http://www.snowdream.tech/2016/10/17/android-genymotion-install-and-settings/</id>
    <published>2016-10-17T03:54:52.000Z</published>
    <updated>2018-04-19T02:49:42.011Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>作者：snowdream<br>Email：yanghui1986527#gmail.com<br>Github: <a href="https://github.com/snowdream" target="_blank" rel="noopener">https://github.com/snowdream</a><br>QQ 群: 529327615<br>原文地址：<a href="https://snowdream.github.io/blog/2016/10/17/android-genymotion-install-and-settings/" target="_blank" rel="noopener">https://snowdream.github.io/blog/2016/10/17/android-genymotion-install-and-settings/</a></p></blockquote><p>注： 由<a href="https://github.com/snowdream" target="_blank" rel="noopener">snowdream</a>收集整理</p><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>Genymotion是一款基于x86架构的Android模拟器，由于系统启动速度，应用运行速度远远快于Android SDK自带模拟器而受到广泛应用。</p><h2 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h2><h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><ul><li>系统启动速度快</li><li>应用运行速度快</li><li>跨平台</li><li>IDE支持</li></ul><h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><ul><li>与真机相比，无法支持一些硬件相关的传感器特性等</li><li>由于市场上大部分应用都是基于ARM架构来编译的，因此，与默认模拟器，真机相比，对于包含仅支持ARM架构的so的应用，默认不支持。</li></ul><p>注：基于x86架构的模拟器/真机，兼容ARM指令有两个解决方案：</p><ol><li>对于x86真机，x86处理器已经能够基本兼容ARM指令了。参考<a href="http://blog.csdn.net/hshl1214/article/details/50972589" target="_blank" rel="noopener">《涨姿势！x86处理器兼容ARM架构App的秘密》</a></li><li>对于Genymotion模拟器，则通过安装ARM_Translation_Android来进行兼容。</li></ol><h2 id="安装Genymotion"><a href="#安装Genymotion" class="headerlink" title="安装Genymotion"></a>安装Genymotion</h2><h3 id="安装步骤"><a href="#安装步骤" class="headerlink" title="安装步骤"></a>安装步骤</h3><ol><li><p><a href="https://www.virtualbox.org/wiki/Downloads" target="_blank" rel="noopener">安装虚拟机VirtualBox  </a></p></li><li><p><a href="https://www.genymotion.com/account/create/" target="_blank" rel="noopener">注册Genymotion帐号</a></p></li><li><p><a href="https://www.genymotion.com/download/" target="_blank" rel="noopener">登录，下载并安装Genymotion</a></p></li></ol><h3 id="安装指南"><a href="#安装指南" class="headerlink" title="安装指南"></a>安装指南</h3><p>详细安装步骤，请参考以下文章：</p><ol><li><a href="https://docs.genymotion.com/Content/01_Get_Started/Installation.htm" target="_blank" rel="noopener">Installation</a></li><li><a href="http://www.jianshu.com/p/cb0e43e0996e" target="_blank" rel="noopener">Genymotion安装方法</a></li></ol><img src="/2016/10/17/android-genymotion-install-and-settings/genymotion.png" title="[Genymotion效果图]"><h2 id="安装ARM-Translation-Android系列包"><a href="#安装ARM-Translation-Android系列包" class="headerlink" title="安装ARM_Translation_Android系列包"></a>安装ARM_Translation_Android系列包</h2><p>由于genymotion是基于x86的，而大部分应用都是基于ARM的，因此，我们需要安装一个ARM_Translation_Android系列包来增强兼容性。</p><h3 id="安装步骤-1"><a href="#安装步骤-1" class="headerlink" title="安装步骤"></a>安装步骤</h3><ol><li>点击下载ARM_Translation_Android系列包<ul><li>Android 4.4及以下：     <a href="http://www.mirrorcreator.com/files/0ZIO8PME/Genymotion-ARM-Translation_v1.1.zip_links" target="_blank" rel="noopener">ARM Translation Installer v1.1</a></li><li>Android 5.x： <a href="https://mega.nz/#!Mt8kyBxa!iVJYC7eI7ruLVoaarWIa85QOm_VlH53G0knVGpoSlAE" target="_blank" rel="noopener">ARM_Translation_Lollipop</a></li><li>Android 6.x： <a href="https://mega.nz/#!p4lFlCZR!TFsb8dMqNdAJjKoCDPDDvNtcQdEB0-KkVlTgQVwG20s" target="_blank" rel="noopener">ARM_Translation_Marshmallow</a></li></ul></li><li>将下载的zip包，拖进Genymotion模拟器窗口，按照提示安装</li><li>安装成功后，重启Genymotion模拟器即可。</li></ol><h3 id="安装指南-1"><a href="#安装指南-1" class="headerlink" title="安装指南"></a>安装指南</h3><ol><li><a href="https://gist.github.com/wbroek/9321145" target="_blank" rel="noopener">Genymotion with Google Play Services</a></li><li><a href="http://23pin.logdown.com/posts/294446-genymotion-use-arm-translation-on-5x-image" target="_blank" rel="noopener">Use ARM Translation on 5.x image</a></li><li><a href="http://23pin.logdown.com/posts/691046-genymotion-use-arm-translation-on-6x-image" target="_blank" rel="noopener">Use ARM Translation on 6.x image</a></li></ol><p>注：以上步骤，便可满足大部分的开发测试需求。以下的步骤，都是可选步骤。</p><p>下面是安装微信的效果</p><img src="/2016/10/17/android-genymotion-install-and-settings/wechat.png" title="[wechat]"><h2 id="安装Google-Apps"><a href="#安装Google-Apps" class="headerlink" title="安装Google Apps"></a>安装Google Apps</h2><ol><li>根据平台，android版本等选择不同的安装包，下载。<br><a href="http://opengapps.org/" target="_blank" rel="noopener">http://opengapps.org/</a><br><a href="https://github.com/opengapps/opengapps" target="_blank" rel="noopener">https://github.com/opengapps/opengapps</a></li><li>将下载的zip包，拖进Genymotion模拟器窗口，按照提示安装</li><li>安装成功后，重启Genymotion模拟器即可。</li></ol><h2 id="安装Xposed"><a href="#安装Xposed" class="headerlink" title="安装Xposed"></a>安装Xposed</h2><ol><li>根据平台，android版本等选择不同的安装包，下载。<br><a href="http://dl-xda.xposed.info/framework/" target="_blank" rel="noopener">http://dl-xda.xposed.info/framework/</a><br>其中，sdk21，sdk22，sdk23，分别对应Android 5.0，5.1， 6.0.</li><li>将下载的zip包，拖进Genymotion模拟器窗口，按照提示安装</li><li>安装成功后，重启Genymotion模拟器即可。</li><li>对于Android 5.0以上的手机，请前往XDA论坛主题贴下载附件 XposedInstaller_3.0_alpha4.apk，并安装。<br>下载地址：<a href="http://forum.xda-developers.com/showthread.php?t=3034811" target="_blank" rel="noopener">http://forum.xda-developers.com/showthread.php?t=3034811</a><br>如果你看到以下界面，恭喜你，Xposed Framework安装完成。</li></ol><img src="/2016/10/17/android-genymotion-install-and-settings/xposed3.png" title="[xposed3]"><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol><li><a href="http://www.jianshu.com/p/82afc1c0212e" target="_blank" rel="noopener">Android模拟器Genymotion</a></li><li><a href="http://www.jianshu.com/p/cb0e43e0996e" target="_blank" rel="noopener">Genymotion安装方法</a></li><li><a href="http://www.jianshu.com/p/7e87693e1dcd" target="_blank" rel="noopener">快到极致的 Android 模拟器Genymotion</a></li><li><a href="http://www.jianshu.com/p/66ec5295fc65" target="_blank" rel="noopener">Genymotion那点事儿</a></li><li><a href="http://repo.xposed.info/" target="_blank" rel="noopener">Xposed 官网</a></li><li><a href="http://forum.xda-developers.com/xposed" target="_blank" rel="noopener">Xposed XDA论坛</a></li><li><a href="http://forum.xda-developers.com/showthread.php?t=3034811" target="_blank" rel="noopener">[OFFICIAL] Xposed for Lollipop/Marshmallow [Android 5.0/5.1/6.0, v86, 2016/10/16]</a></li><li><a href="https://snowdream.github.io/blog/2016/09/02/android-install-xposed-framework/" target="_blank" rel="noopener">Xposed框架的安装</a></li><li><a href="https://gist.github.com/wbroek/9321145" target="_blank" rel="noopener">Genymotion with Google Play Services</a></li><li><a href="http://23pin.logdown.com/posts/294446-genymotion-use-arm-translation-on-5x-image" target="_blank" rel="noopener">Use ARM Translation on 5.x image</a></li><li><a href="http://23pin.logdown.com/posts/691046-genymotion-use-arm-translation-on-6x-image" target="_blank" rel="noopener">Use ARM Translation on 6.x image</a></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;作者：snowdream&lt;br&gt;Email：yanghui1986527#gmail.com&lt;br&gt;Github: &lt;a href=&quot;https://github.com/snowdream&quot; target=&quot;_blank&quot; rel=&quot;noopen
      
    
    </summary>
    
      <category term="android" scheme="http://www.snowdream.tech/categories/android/"/>
    
    
      <category term="android" scheme="http://www.snowdream.tech/tags/android/"/>
    
  </entry>
  
  <entry>
    <title>Android手机暗码浅谈</title>
    <link href="http://www.snowdream.tech/2016/10/11/android-secret-codes/"/>
    <id>http://www.snowdream.tech/2016/10/11/android-secret-codes/</id>
    <published>2016-10-11T02:41:00.000Z</published>
    <updated>2018-04-19T02:49:42.023Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>作者：snowdream<br>Email：yanghui1986527#gmail.com<br>Github: <a href="https://github.com/snowdream" target="_blank" rel="noopener">https://github.com/snowdream</a><br>QQ 群: 529327615<br>原文地址：<a href="https://snowdream.github.io/blog/2016/10/11/android-secret-codes/" target="_blank" rel="noopener">https://snowdream.github.io/blog/2016/10/11/android-secret-codes/</a></p></blockquote><p>注： 本文根据<a href="http://simonmarquis.github.io/Android-SecretCodes/" target="_blank" rel="noopener">《Android-SecretCodes》</a>翻译整理。</p><h2 id="什么是暗码？"><a href="#什么是暗码？" class="headerlink" title="什么是暗码？"></a>什么是暗码？</h2><p>在android系统中，暗码就是类似这种样式的字符串：  <code>*#*#&lt;code&gt;#*#*</code> </p><p>如果这样的系统暗码执行，系统会触发下面的方法：（来自 AOSP Android Open Source Project）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">static private boolean handleSecretCode(Context context, String input) &#123;</span><br><span class="line">    int len = input.length();</span><br><span class="line">    if (len &gt; 8 &amp;&amp; input.startsWith(&quot;*#*#&quot;) &amp;&amp; input.endsWith(&quot;#*#*&quot;)) &#123;</span><br><span class="line">        Intent intent = new Intent(TelephonyIntents.SECRET_CODE_ACTION,</span><br><span class="line">                Uri.parse(&quot;android_secret_code://&quot; + input.substring(4, len - 4)));</span><br><span class="line">        context.sendBroadcast(intent);</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return false;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="如何运行暗码"><a href="#如何运行暗码" class="headerlink" title="如何运行暗码?"></a>如何运行暗码?</h2><p>有两种方式可以执行运行暗码：</p><p>直接在手机电话拨号界面输入暗码，例如：<code>*#*#123456789#*#*</code></p><p>或者直接在代码中进行调用。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">String secretCode = &quot;123456789&quot;;</span><br><span class="line">Intent intent = new Intent(Intent.ACTION_DIAL);    </span><br><span class="line">intent.setData(Uri.parse(&quot;tel:*#*#&quot; + secretCode + &quot;#*#*&quot;));</span><br><span class="line">startActivity(intent);</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">String secretCode = &quot;123456789&quot;;</span><br><span class="line">String action = &quot;android.provider.Telephony.SECRET_CODE&quot;;</span><br><span class="line">Uri uri = Uri.parse(&quot;android_secret_code://&quot; + secretCode);</span><br><span class="line">Intent intent = new Intent(action, uri);</span><br><span class="line">sendBroadcast(intent);</span><br></pre></td></tr></table></figure><h2 id="如何创建自定义暗码？"><a href="#如何创建自定义暗码？" class="headerlink" title="如何创建自定义暗码？"></a>如何创建自定义暗码？</h2><p>在你的应用AndroidManifest.xml文件中，增加以下代码，用来定义手机暗码。</p><p>不管什么时候暗码 <code>*#*#123456789#*#*</code> 被触发，你都将收到对应的广播。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;receiver android:name=&quot;.MySecretCodeReceiver&quot;&gt;</span><br><span class="line">    &lt;intent-filter&gt;</span><br><span class="line">        &lt;action android:name=&quot;android.provider.Telephony.SECRET_CODE&quot; /&gt;</span><br><span class="line">        &lt;data android:scheme=&quot;android_secret_code&quot; android:host=&quot;123456789&quot; /&gt;</span><br><span class="line">    &lt;/intent-filter&gt;</span><br><span class="line">&lt;/receiver&gt;</span><br></pre></td></tr></table></figure></p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol><li><a href="http://simonmarquis.github.io/Android-SecretCodes/" target="_blank" rel="noopener">Android Secret Codes</a></li><li><a href="http://blog.csdn.net/huangjuecheng/article/details/7261211" target="_blank" rel="noopener">话说android系统之暗码</a></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;作者：snowdream&lt;br&gt;Email：yanghui1986527#gmail.com&lt;br&gt;Github: &lt;a href=&quot;https://github.com/snowdream&quot; target=&quot;_blank&quot; rel=&quot;noopen
      
    
    </summary>
    
      <category term="android" scheme="http://www.snowdream.tech/categories/android/"/>
    
    
      <category term="android" scheme="http://www.snowdream.tech/tags/android/"/>
    
  </entry>
  
</feed>
